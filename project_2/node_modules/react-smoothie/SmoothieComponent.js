"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DefaultTooltip = DefaultTooltip;
Object.defineProperty(exports, "TimeSeries", {
  enumerable: true,
  get: function get() {
    return _smoothie.TimeSeries;
  }
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _reactAutobind = _interopRequireDefault(require("react-autobind"));

var _smoothie = require("smoothie");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function DefaultTooltip(props) {
  if (!props.display) return _react.default.createElement("div", null);
  return _react.default.createElement("div", {
    style: {
      userSelect: 'none'
    }
  }, _react.default.createElement("strong", null, props.time), props.data ? _react.default.createElement("ul", null, props.data.map(function (data, i) {
    return _react.default.createElement("li", {
      key: i
    }, data.value);
  })) : _react.default.createElement("div", null));
}

function seriesOptsParser(opts) {
  var ret = {};
  var R = opts.r,
      G = opts.g,
      B = opts.b;
  if (R === undefined) R = 0;
  if (G === undefined) G = 0;
  if (B === undefined) B = 0;

  if (opts.fillStyle === undefined && R + G + B) {
    opts.fillStyle = {};
  }

  if (opts.strokeStyle === undefined && R + G + B) {
    opts.strokeStyle = {};
  }

  Object.entries(opts).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        name = _ref2[0],
        val = _ref2[1];

    switch (name) {
      case 'data':
      case 'r':
      case 'g':
      case 'b':
        return;

      default:
    }

    switch (_typeof(val)) {
      case 'string':
      case 'number':
      case 'boolean':
        ret[name] = val;
        return;

      default:
    }

    var r = val.r,
        g = val.g,
        b = val.b,
        a = val.a;
    if (r === undefined) r = R;
    if (g === undefined) g = G;
    if (b === undefined) b = B;

    if (a === undefined) {
      a = name == 'strokeStyle' ? 1 : r + g + b ? 0.2 : 0;
    }

    ret[name] = "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(a, ")");
  });
  return ret;
}

var SmoothieComponent =
/*#__PURE__*/
function (_React$Component) {
  _inherits(SmoothieComponent, _React$Component);

  function SmoothieComponent(props) {
    var _this;

    _classCallCheck(this, SmoothieComponent);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SmoothieComponent).call(this, props));
    _this.state = {
      tooltip: {}
    };
    (0, _reactAutobind.default)(_assertThisInitialized(_assertThisInitialized(_this)));
    var opts = Object.assign({}, props); // SmoothieChart's tooltip injects a div at the end of the page.
    // This will not do. We shall make our own and intercept the data.

    var updateTooltip = function updateTooltip(o) {
      _this.setState(function (state) {
        Object.assign(state.tooltip, o);
        return state;
      });
    };

    opts.tooltipFormatter = function (t, data) {
      if (!props.doNotSimplifyData) {
        data = data.map(function (set) {
          return {
            index: set.index,
            value: set.value,
            series: {
              options: set.series.options
            }
          };
        });
      }

      updateTooltip({
        time: t,
        data: data
      });
    };

    opts.tooltip = !!opts.tooltip;
    var smoothie = new _smoothie.SmoothieChart(opts); // Intercept the set data

    smoothie.tooltipEl = {
      style: {
        set display(v) {
          updateTooltip({
            display: v == 'block'
          });
        },

        set top(v) {
          updateTooltip({
            top: smoothie.mouseY,
            left: smoothie.mouseX
          });
        }

      }
    };

    if (props.series) {
      props.series.forEach(function (series) {
        if (!(series.data instanceof _smoothie.TimeSeries)) {
          throw Error('Invalid type passed to series option');
        }

        smoothie.addTimeSeries(series.data, seriesOptsParser(series));
      });
    }

    _this.smoothie = smoothie;
    return _this;
  }

  _createClass(SmoothieComponent, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.smoothie.stop();
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var style = {};

      if (this.props.responsive === true) {
        style.width = '100%';
        style.height = this.props.height;
      } // Prevent extra pixels in wrapping element


      style.display = 'block';
      style = this.props.style || style;
      var tooltipParentStyle = this.props.tooltipParentStyle || {
        pointerEvents: 'none',
        position: 'absolute',
        left: this.state.tooltip.left,
        top: this.state.tooltip.top
      };
      var Tooltip = this.props.tooltip;

      if (Tooltip === true) {
        Tooltip = DefaultTooltip;
      }

      var canvas = _react.default.createElement("canvas", {
        className: this.props.classNameCanvas || this.props.className,
        style: style,
        width: this.props.responsive === true ? undefined : this.props.width,
        height: this.props.height,
        ref: function ref(canv) {
          return canv && _this2.smoothie.streamTo(canv, _this2.props.streamDelay);
        }
      });

      var tooltip;

      if (Tooltip) {
        tooltip = _react.default.createElement("div", {
          style: tooltipParentStyle,
          className: this.props.classNameTooltip
        }, _react.default.createElement(Tooltip, this.state.tooltip));
      }

      return _react.default.createElement("div", {
        className: this.props.classNameContainer,
        style: this.props.containerStyle || {
          position: 'relative'
        }
      }, canvas, tooltip);
    }
  }, {
    key: "addTimeSeries",
    value: function addTimeSeries(tsOpts, addOpts) {
      if (addOpts === undefined) {
        addOpts = tsOpts;
        tsOpts = undefined;
      }

      var ts = tsOpts instanceof _smoothie.TimeSeries ? tsOpts : new _smoothie.TimeSeries(tsOpts);
      this.smoothie.addTimeSeries(ts, seriesOptsParser(addOpts));
      return ts;
    }
  }]);

  return SmoothieComponent;
}(_react.default.Component);

exports.default = SmoothieComponent;
SmoothieComponent.defaultProps = {
  width: 800,
  height: 200,
  streamDelay: 0
};