{"ast":null,"code":"'use strict'; // ==================================================================================\n// docker.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2018\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 13. Docker\n// ----------------------------------------------------------------------------------\n\nvar util = require('./util');\n\nvar DockerSocket = require('./dockerSocket');\n\nvar _platform = process.platform;\n\nvar _windows = _platform === 'win32';\n\nvar _docker_container_stats = {};\n\nvar _docker_socket;\n\nvar _docker_last_read = 0; // --------------------------\n// get containers (parameter all: get also inactive/exited containers)\n\nfunction dockerContainers(all, callback) {\n  function inContainers(containers, id) {\n    var filtered = containers.filter(function (obj) {\n      /**\n       * @namespace\n       * @property {string}  Id\n       */\n      return obj.Id && obj.Id === id;\n    });\n    return filtered.length > 0;\n  } // fallback - if only callback is given\n\n\n  if (util.isFunction(all) && !callback) {\n    callback = all;\n    all = false;\n  }\n\n  all = all || false;\n  var result = [];\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      if (!_docker_socket) {\n        _docker_socket = new DockerSocket();\n      }\n\n      _docker_socket.listContainers(all, function (data) {\n        var docker_containers = {};\n\n        try {\n          docker_containers = data;\n\n          if (docker_containers && Object.prototype.toString.call(docker_containers) === '[object Array]' && docker_containers.length > 0) {\n            docker_containers.forEach(function (element) {\n              /**\n               * @namespace\n               * @property {string}  Id\n               * @property {string}  Name\n               * @property {string}  Image\n               * @property {string}  ImageID\n               * @property {string}  Command\n               * @property {number}  Created\n               * @property {string}  State\n               * @property {Array}  Names\n               * @property {Array}  Ports\n               * @property {Array}  Mounts\n               */\n              if (element.Names && Object.prototype.toString.call(element.Names) === '[object Array]' && element.Names.length > 0) {\n                element.Name = element.Names[0].replace(/^\\/|\\/$/g, '');\n              }\n\n              result.push({\n                id: element.Id,\n                name: element.Name,\n                image: element.Image,\n                imageID: element.ImageID,\n                command: element.Command,\n                created: element.Created,\n                state: element.State,\n                ports: element.Ports,\n                mounts: element.Mounts // hostconfig: element.HostConfig,\n                // network: element.NetworkSettings\n\n              });\n            });\n          }\n        } catch (err) {\n          util.noop();\n        } // }\n        // GC in _docker_container_stats\n\n\n        for (var key in _docker_container_stats) {\n          if (_docker_container_stats.hasOwnProperty(key)) {\n            if (!inContainers(docker_containers, key)) delete _docker_container_stats[key];\n          }\n        }\n\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.dockerContainers = dockerContainers; // --------------------------\n// helper functions for calculation of docker stats\n\nfunction docker_calcCPUPercent(cpu_stats, precpu_stats) {\n  /**\n   * @namespace\n   * @property {object}  cpu_usage\n   * @property {number}  cpu_usage.total_usage\n   * @property {number}  system_cpu_usage\n   * @property {object}  cpu_usage\n   * @property {Array}  cpu_usage.percpu_usage\n   */\n  if (!_windows) {\n    var cpuPercent = 0.0; // calculate the change for the cpu usage of the container in between readings\n\n    var cpuDelta = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage; // calculate the change for the entire system between readings\n\n    var systemDelta = cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage;\n\n    if (systemDelta > 0.0 && cpuDelta > 0.0) {\n      // calculate the change for the cpu usage of the container in between readings\n      cpuPercent = cpuDelta / systemDelta * cpu_stats.cpu_usage.percpu_usage.length * 100.0;\n    }\n\n    return cpuPercent;\n  } else {\n    var nanoSecNow = util.nanoSeconds();\n    var _cpuPercent = 0.0;\n\n    if (_docker_last_read > 0) {\n      var possIntervals = nanoSecNow - _docker_last_read; //  / 100 * os.cpus().length;\n\n      var intervalsUsed = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;\n\n      if (possIntervals > 0) {\n        _cpuPercent = 100.0 * intervalsUsed / possIntervals;\n      }\n    }\n\n    _docker_last_read = nanoSecNow;\n    return _cpuPercent;\n  }\n}\n\nfunction docker_calcNetworkIO(networks) {\n  var rx;\n  var tx;\n\n  for (var key in networks) {\n    // skip loop if the property is from prototype\n    if (!networks.hasOwnProperty(key)) continue;\n    /**\n     * @namespace\n     * @property {number}  rx_bytes\n     * @property {number}  tx_bytes\n     */\n\n    var obj = networks[key];\n    rx = +obj.rx_bytes;\n    tx = +obj.tx_bytes;\n  }\n\n  return {\n    rx: rx,\n    tx: tx\n  };\n}\n\nfunction docker_calcBlockIO(blkio_stats) {\n  var result = {\n    r: 0,\n    w: 0\n  };\n  /**\n   * @namespace\n   * @property {Array}  io_service_bytes_recursive\n   */\n\n  if (blkio_stats && blkio_stats.io_service_bytes_recursive && Object.prototype.toString.call(blkio_stats.io_service_bytes_recursive) === '[object Array]' && blkio_stats.io_service_bytes_recursive.length > 0) {\n    blkio_stats.io_service_bytes_recursive.forEach(function (element) {\n      /**\n       * @namespace\n       * @property {string}  op\n       * @property {number}  value\n       */\n      if (element.op && element.op.toLowerCase() === 'read' && element.value) {\n        result.r += element.value;\n      }\n\n      if (element.op && element.op.toLowerCase() === 'write' && element.value) {\n        result.w += element.value;\n      }\n    });\n  }\n\n  return result;\n} // --------------------------\n// container stats (for one container)\n\n\nfunction dockerContainerStats(containerID, callback) {\n  containerID = containerID || '';\n  var result = {\n    id: containerID,\n    mem_usage: 0,\n    mem_limit: 0,\n    mem_percent: 0,\n    cpu_percent: 0,\n    pids: 0,\n    netIO: {\n      rx: 0,\n      wx: 0\n    },\n    blockIO: {\n      r: 0,\n      w: 0\n    }\n  };\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      if (containerID) {\n        if (!_docker_socket) {\n          _docker_socket = new DockerSocket();\n        }\n\n        _docker_socket.getStats(containerID, function (data) {\n          try {\n            var stats = data;\n            /**\n             * @namespace\n             * @property {Object}  memory_stats\n             * @property {number}  memory_stats.usage\n             * @property {number}  memory_stats.limit\n             * @property {Object}  cpu_stats\n             * @property {Object}  pids_stats\n             * @property {number}  pids_stats.current\n             * @property {Object}  networks\n             * @property {Object}  blkio_stats\n             */\n\n            if (!stats.message) {\n              result.mem_usage = stats.memory_stats && stats.memory_stats.usage ? stats.memory_stats.usage : 0;\n              result.mem_limit = stats.memory_stats && stats.memory_stats.limit ? stats.memory_stats.limit : 0;\n              result.mem_percent = stats.memory_stats && stats.memory_stats.usage && stats.memory_stats.limit ? stats.memory_stats.usage / stats.memory_stats.limit * 100.0 : 0;\n              result.cpu_percent = stats.cpu_stats && stats.precpu_stats ? docker_calcCPUPercent(stats.cpu_stats, stats.precpu_stats) : 0;\n              result.pids = stats.pids_stats && stats.pids_stats.current ? stats.pids_stats.current : 0;\n              if (stats.networks) result.netIO = docker_calcNetworkIO(stats.networks);\n              if (stats.blkio_stats) result.blockIO = docker_calcBlockIO(stats.blkio_stats);\n              result.cpu_stats = stats.cpu_stats ? stats.cpu_stats : {};\n              result.precpu_stats = stats.precpu_stats ? stats.precpu_stats : {};\n              result.memory_stats = stats.memory_stats ? stats.memory_stats : {};\n              result.networks = stats.networks ? stats.networks : {};\n            }\n          } catch (err) {\n            util.noop();\n          } // }\n\n\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        });\n      } else {\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.dockerContainerStats = dockerContainerStats; // --------------------------\n// container processes (for one container)\n\nfunction dockerContainerProcesses(containerID, callback) {\n  containerID = containerID || '';\n  var result = [];\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      if (containerID) {\n        if (!_docker_socket) {\n          _docker_socket = new DockerSocket();\n        }\n\n        _docker_socket.getProcesses(containerID, function (data) {\n          /**\n           * @namespace\n           * @property {Array}  Titles\n           * @property {Array}  Processes\n           **/\n          try {\n            if (data && data.Titles && data.Processes) {\n              var titles = data.Titles.map(function (value) {\n                return value.toUpperCase();\n              });\n              var pos_pid = titles.indexOf('PID');\n              var pos_ppid = titles.indexOf('PPID');\n              var pos_pgid = titles.indexOf('PGID');\n              var pos_vsz = titles.indexOf('VSZ');\n              var pos_time = titles.indexOf('TIME');\n              var pos_elapsed = titles.indexOf('ELAPSED');\n              var pos_ni = titles.indexOf('NI');\n              var pos_ruser = titles.indexOf('RUSER');\n              var pos_user = titles.indexOf('USER');\n              var pos_rgroup = titles.indexOf('RGROUP');\n              var pos_group = titles.indexOf('GROUP');\n              var pos_stat = titles.indexOf('STAT');\n              var pos_rss = titles.indexOf('RSS');\n              var pos_command = titles.indexOf('COMMAND');\n              data.Processes.forEach(function (process) {\n                result.push({\n                  pid_host: pos_pid >= 0 ? process[pos_pid] : '',\n                  ppid: pos_ppid >= 0 ? process[pos_ppid] : '',\n                  pgid: pos_pgid >= 0 ? process[pos_pgid] : '',\n                  user: pos_user >= 0 ? process[pos_user] : '',\n                  ruser: pos_ruser >= 0 ? process[pos_ruser] : '',\n                  group: pos_group >= 0 ? process[pos_group] : '',\n                  rgroup: pos_rgroup >= 0 ? process[pos_rgroup] : '',\n                  stat: pos_stat >= 0 ? process[pos_stat] : '',\n                  time: pos_time >= 0 ? process[pos_time] : '',\n                  elapsed: pos_elapsed >= 0 ? process[pos_elapsed] : '',\n                  nice: pos_ni >= 0 ? process[pos_ni] : '',\n                  rss: pos_rss >= 0 ? process[pos_rss] : '',\n                  vsz: pos_vsz >= 0 ? process[pos_vsz] : '',\n                  command: pos_command >= 0 ? process[pos_command] : ''\n                });\n              });\n            }\n          } catch (err) {\n            util.noop();\n          }\n\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        });\n      } else {\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.dockerContainerProcesses = dockerContainerProcesses;\n\nfunction dockerAll(callback) {\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      dockerContainers(true).then(function (result) {\n        if (result && Object.prototype.toString.call(result) === '[object Array]' && result.length > 0) {\n          var l = result.length;\n          result.forEach(function (element) {\n            dockerContainerStats(element.id).then(function (res) {\n              // include stats in array\n              element.mem_usage = res.mem_usage;\n              element.mem_limit = res.mem_limit;\n              element.mem_percent = res.mem_percent;\n              element.cpu_percent = res.cpu_percent;\n              element.pids = res.pids;\n              element.netIO = res.netIO;\n              element.blockIO = res.blockIO;\n              element.cpu_stats = res.cpu_stats;\n              element.precpu_stats = res.precpu_stats;\n              element.memory_stats = res.memory_stats;\n              element.networks = res.networks;\n              dockerContainerProcesses(element.id).then(function (processes) {\n                element.processes = processes;\n                l -= 1;\n\n                if (l === 0) {\n                  if (callback) {\n                    callback(result);\n                  }\n\n                  resolve(result);\n                }\n              }); // all done??\n            });\n          });\n        } else {\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        }\n      });\n    });\n  });\n}\n\nexports.dockerAll = dockerAll;","map":null,"metadata":{},"sourceType":"script"}