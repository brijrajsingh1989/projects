{"ast":null,"code":"'use strict'; // ==================================================================================\n// processes.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2018\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 10. Processes\n// ----------------------------------------------------------------------------------\n\nvar os = require('os');\n\nvar exec = require('child_process').exec;\n\nvar execSync = require('child_process').execSync;\n\nvar util = require('./util');\n\nvar _platform = process.platform;\n\nvar _linux = _platform === 'linux';\n\nvar _darwin = _platform === 'darwin';\n\nvar _windows = _platform === 'win32';\n\nvar _freebsd = _platform === 'freebsd';\n\nvar _openbsd = _platform === 'openbsd';\n\nvar _sunos = _platform === 'sunos';\n\nvar _processes_cpu = {\n  all: 0,\n  list: {},\n  ms: 0,\n  result: {}\n};\nvar _services_cpu = {\n  all: 0,\n  list: {},\n  ms: 0,\n  result: {}\n};\nvar _process_cpu = {\n  all: 0,\n  list: {},\n  ms: 0,\n  result: {}\n};\nvar _winStatusValues = {\n  '0': 'unknown',\n  '1': 'other',\n  '2': 'ready',\n  '3': 'running',\n  '4': 'blocked',\n  '5': 'suspended blocked',\n  '6': 'suspended ready',\n  '7': 'terminated',\n  '8': 'stopped',\n  '9': 'growing'\n};\n\nfunction parseTimeWin(time) {\n  time = time || '';\n\n  if (time) {\n    return time.substr(0, 4) + '-' + time.substr(4, 2) + '-' + time.substr(6, 2) + ' ' + time.substr(8, 2) + ':' + time.substr(10, 2) + ':' + time.substr(12, 2);\n  } else {\n    return '';\n  }\n}\n\nfunction parseTimeUnix(time) {\n  var result = time;\n  var parts = time.replace(/ +/g, ' ').split(' ');\n\n  if (parts.length === 5) {\n    result = parts[4] + '-' + ('0' + ('JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC'.indexOf(parts[1].toUpperCase()) / 3 + 1)).slice(-2) + '-' + ('0' + parts[2]).slice(-2) + ' ' + parts[3];\n  }\n\n  return result;\n} // --------------------------\n// PS - services\n// pass a comma separated string with services to check (mysql, apache, postgresql, ...)\n// this function gives an array back, if the services are running.\n\n\nfunction services(srv, callback) {\n  // fallback - if only callback is given\n  if (util.isFunction(srv) && !callback) {\n    callback = srv;\n    srv = '';\n  }\n\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      if (srv) {\n        srv = srv.trim().toLowerCase().replace(/,+/g, ' ').replace(/  +/g, ' ').replace(/ +/g, '|');\n        var srvs = srv.split('|');\n        var result = [];\n        var dataSrv = [];\n        var allSrv = [];\n\n        if (_linux || _freebsd || _openbsd || _darwin) {\n          if ((_linux || _freebsd || _openbsd) && srv === '*') {\n            srv = '';\n            var tmpsrv = execSync('service --status-all 2> /dev/null').toString().split('\\n');\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = tmpsrv[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var s = _step.value;\n                var parts = s.split(']');\n\n                if (parts.length === 2) {\n                  srv += (srv !== '' ? '|' : '') + parts[1].trim();\n                  allSrv.push({\n                    name: parts[1].trim(),\n                    running: parts[0].indexOf('+') > 0\n                  });\n                }\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n\n            srvs = srv.split('|');\n          }\n\n          var comm = _darwin ? 'ps -caxo pcpu,pmem,pid,command' : 'ps -axo pcpu,pmem,pid,command';\n\n          if (srv !== '' && srvs.length > 0) {\n            exec(comm + ' | grep -v grep | grep -iE \"' + srv + '\"', {\n              maxBuffer: 1024 * 2000\n            }, function (error, stdout) {\n              if (!error) {\n                var lines = stdout.toString().replace(/ +/g, ' ').replace(/,+/g, '.').split('\\n');\n                srvs.forEach(function (srv) {\n                  var ps;\n\n                  if (_darwin) {\n                    ps = lines.filter(function (e) {\n                      return e.toLowerCase().indexOf(srv) !== -1;\n                    });\n                  } else {\n                    ps = lines.filter(function (e) {\n                      return e.toLowerCase().indexOf(' ' + srv + ':') !== -1 || e.toLowerCase().indexOf('/' + srv) !== -1;\n                    });\n                  }\n\n                  var singleSrv = allSrv.filter(function (item) {\n                    return item.name === srv;\n                  });\n                  var pids = [];\n                  var _iteratorNormalCompletion2 = true;\n                  var _didIteratorError2 = false;\n                  var _iteratorError2 = undefined;\n\n                  try {\n                    for (var _iterator2 = ps[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                      var p = _step2.value;\n                      pids.push(p.trim().split(' ')[2]);\n                    }\n                  } catch (err) {\n                    _didIteratorError2 = true;\n                    _iteratorError2 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                        _iterator2.return();\n                      }\n                    } finally {\n                      if (_didIteratorError2) {\n                        throw _iteratorError2;\n                      }\n                    }\n                  }\n\n                  result.push({\n                    name: srv,\n                    running: allSrv.length && singleSrv.length ? singleSrv[0].running : ps.length > 0,\n                    startmode: '',\n                    pids: pids,\n                    pcpu: parseFloat(ps.reduce(function (pv, cv) {\n                      return pv + parseFloat(cv.trim().split(' ')[0]);\n                    }, 0).toFixed(2)),\n                    pmem: parseFloat(ps.reduce(function (pv, cv) {\n                      return pv + parseFloat(cv.trim().split(' ')[1]);\n                    }, 0).toFixed(2))\n                  });\n                });\n\n                if (_linux) {\n                  // calc process_cpu - ps is not accurate in linux!\n                  var cmd = 'cat /proc/stat | grep \"cpu \"';\n\n                  for (var i in result) {\n                    for (var j in result[i].pids) {\n                      cmd += ';cat /proc/' + result[i].pids[j] + '/stat';\n                    }\n                  }\n\n                  exec(cmd, {\n                    maxBuffer: 1024 * 2000\n                  }, function (error, stdout) {\n                    var curr_processes = stdout.toString().split('\\n'); // first line (all - /proc/stat)\n\n                    var all = parseProcStat(curr_processes.shift()); // process\n\n                    var list_new = {};\n                    var resultProcess = {};\n\n                    for (var _i = 0; _i < curr_processes.length; _i++) {\n                      resultProcess = calcProcStatLinux(curr_processes[_i], all, _services_cpu);\n\n                      if (resultProcess.pid) {\n                        var listPos = -1;\n\n                        for (var _i2 in result) {\n                          for (var _j in result[_i2].pids) {\n                            if (parseInt(result[_i2].pids[_j]) === parseInt(resultProcess.pid)) {\n                              listPos = _i2;\n                            }\n                          }\n                        }\n\n                        if (listPos >= 0) {\n                          result[listPos].pcpu += resultProcess.pcpuu + resultProcess.pcpus;\n                        } // save new values\n\n\n                        list_new[resultProcess.pid] = {\n                          pcpuu: resultProcess.pcpuu,\n                          pcpus: resultProcess.pcpus,\n                          utime: resultProcess.utime,\n                          stime: resultProcess.stime,\n                          cutime: resultProcess.cutime,\n                          cstime: resultProcess.cstime\n                        };\n                      }\n                    } // store old values\n\n\n                    _services_cpu.all = all;\n                    _services_cpu.list = list_new;\n                    _services_cpu.ms = Date.now() - _services_cpu.ms;\n                    _services_cpu.result = result;\n\n                    if (callback) {\n                      callback(result);\n                    }\n\n                    resolve(result);\n                  });\n                } else {\n                  if (callback) {\n                    callback(result);\n                  }\n\n                  resolve(result);\n                }\n              } else {\n                exec('ps -o comm | grep -v grep | egrep \"' + srv + '\"', {\n                  maxBuffer: 1024 * 2000\n                }, function (error, stdout) {\n                  if (!error) {\n                    var _lines = stdout.toString().replace(/ +/g, ' ').replace(/,+/g, '.').split('\\n');\n\n                    srvs.forEach(function (srv) {\n                      var ps = _lines.filter(function (e) {\n                        return e.indexOf(srv) !== -1;\n                      });\n\n                      result.push({\n                        name: srv,\n                        running: ps.length > 0,\n                        startmode: '',\n                        pcpu: 0,\n                        pmem: 0\n                      });\n                    });\n\n                    if (callback) {\n                      callback(result);\n                    }\n\n                    resolve(result);\n                  } else {\n                    srvs.forEach(function (srv) {\n                      result.push({\n                        name: srv,\n                        running: false,\n                        startmode: '',\n                        pcpu: 0,\n                        pmem: 0\n                      });\n                    });\n\n                    if (callback) {\n                      callback(result);\n                    }\n\n                    resolve(result);\n                  }\n                });\n              }\n            });\n          } else {\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          }\n        }\n\n        if (_windows) {\n          try {\n            exec(util.getWmic() + ' service get /value', util.execOptsWin, function (error, stdout) {\n              if (!error) {\n                var serviceSections = stdout.split(/\\n\\s*\\n/);\n\n                for (var i = 0; i < serviceSections.length; i++) {\n                  if (serviceSections[i].trim() !== '') {\n                    var lines = serviceSections[i].trim().split('\\r\\n');\n                    var srvName = util.getValue(lines, 'Name', '=', true).toLowerCase();\n                    var started = util.getValue(lines, 'Started', '=', true);\n                    var startMode = util.getValue(lines, 'StartMode', '=', true);\n\n                    if (srv === '*' || srvs.indexOf(srvName) >= 0) {\n                      result.push({\n                        name: srvName,\n                        running: started === 'TRUE',\n                        startmode: startMode,\n                        pcpu: 0,\n                        pmem: 0\n                      });\n                      dataSrv.push(srvName);\n                    }\n                  }\n                }\n\n                if (srv !== '*') {\n                  var srvsMissing = srvs.filter(function (e) {\n                    return dataSrv.indexOf(e) === -1;\n                  });\n                  srvsMissing.forEach(function (srvName) {\n                    result.push({\n                      name: srvName,\n                      running: false,\n                      startmode: '',\n                      pcpu: 0,\n                      pmem: 0\n                    });\n                  });\n                }\n\n                if (callback) {\n                  callback(result);\n                }\n\n                resolve(result);\n              } else {\n                srvs.forEach(function (srvName) {\n                  result.push({\n                    name: srvName,\n                    running: false,\n                    startmode: '',\n                    pcpu: 0,\n                    pmem: 0\n                  });\n                });\n\n                if (callback) {\n                  callback(result);\n                }\n\n                resolve(result);\n              }\n            });\n          } catch (e) {\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          }\n        }\n      } else {\n        if (callback) {\n          callback({});\n        }\n\n        resolve({});\n      }\n    });\n  });\n}\n\nexports.services = services;\n\nfunction parseProcStat(line) {\n  var parts = line.replace(/ +/g, ' ').split(' ');\n  var user = parts.length >= 2 ? parseInt(parts[1]) : 0;\n  var nice = parts.length >= 3 ? parseInt(parts[2]) : 0;\n  var system = parts.length >= 4 ? parseInt(parts[3]) : 0;\n  var idle = parts.length >= 5 ? parseInt(parts[4]) : 0;\n  var iowait = parts.length >= 6 ? parseInt(parts[5]) : 0;\n  var irq = parts.length >= 7 ? parseInt(parts[6]) : 0;\n  var softirq = parts.length >= 8 ? parseInt(parts[7]) : 0;\n  var steal = parts.length >= 9 ? parseInt(parts[8]) : 0;\n  var guest = parts.length >= 10 ? parseInt(parts[9]) : 0;\n  var guest_nice = parts.length >= 11 ? parseInt(parts[10]) : 0;\n  return user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice;\n}\n\nfunction calcProcStatLinux(line, all, _cpu_old) {\n  var statparts = line.replace(/ +/g, ' ').split(')');\n\n  if (statparts.length >= 2) {\n    var parts = statparts[1].split(' ');\n\n    if (parts.length >= 16) {\n      var pid = parseInt(statparts[0].split(' ')[0]);\n      var utime = parseInt(parts[12]);\n      var stime = parseInt(parts[13]);\n      var cutime = parseInt(parts[14]);\n      var cstime = parseInt(parts[15]); // calc\n\n      var pcpuu = 0;\n      var pcpus = 0;\n\n      if (_cpu_old.all > 0 && _cpu_old.list[pid]) {\n        pcpuu = (utime + cutime - _cpu_old.list[pid].utime - _cpu_old.list[pid].cutime) / (all - _cpu_old.all) * 100; // user\n\n        pcpus = (stime + cstime - _cpu_old.list[pid].stime - _cpu_old.list[pid].cstime) / (all - _cpu_old.all) * 100; // system\n      } else {\n        pcpuu = (utime + cutime) / all * 100; // user\n\n        pcpus = (stime + cstime) / all * 100; // system\n      }\n\n      return {\n        pid: pid,\n        utime: utime,\n        stime: stime,\n        cutime: cutime,\n        cstime: cstime,\n        pcpuu: pcpuu,\n        pcpus: pcpus\n      };\n    } else {\n      return {\n        pid: 0,\n        utime: 0,\n        stime: 0,\n        cutime: 0,\n        cstime: 0,\n        pcpuu: 0,\n        pcpus: 0\n      };\n    }\n  } else {\n    return {\n      pid: 0,\n      utime: 0,\n      stime: 0,\n      cutime: 0,\n      cstime: 0,\n      pcpuu: 0,\n      pcpus: 0\n    };\n  }\n}\n\nfunction calcProcStatWin(procStat, all, _cpu_old) {\n  // calc\n  var pcpuu = 0;\n  var pcpus = 0;\n\n  if (_cpu_old.all > 0 && _cpu_old.list[procStat.pid]) {\n    pcpuu = (procStat.utime - _cpu_old.list[procStat.pid].utime) / (all - _cpu_old.all) * 100; // user\n\n    pcpus = (procStat.stime - _cpu_old.list[procStat.pid].stime) / (all - _cpu_old.all) * 100; // system\n  } else {\n    pcpuu = procStat.utime / all * 100; // user\n\n    pcpus = procStat.stime / all * 100; // system\n  }\n\n  return {\n    pid: procStat.pid,\n    utime: procStat.utime,\n    stime: procStat.stime,\n    pcpuu: pcpuu,\n    pcpus: pcpus\n  };\n} // --------------------------\n// running processes\n\n\nfunction processes(callback) {\n  var parsedhead = [];\n\n  function getName(command) {\n    command = command || '';\n    var result = command.split(' ')[0];\n\n    if (result.substr(-1) === ':') {\n      result = result.substr(0, result.length - 1);\n    }\n\n    if (result.substr(0, 1) !== '[') {\n      var parts = result.split('/');\n\n      if (isNaN(parseInt(parts[parts.length - 1]))) {\n        result = parts[parts.length - 1];\n      } else {\n        result = parts[0];\n      }\n    }\n\n    return result;\n  }\n\n  function parseLine(line) {\n    var offset = 0;\n    var offset2 = 0;\n\n    function checkColumn(i) {\n      offset = offset2;\n      offset2 = line.substring(parsedhead[i].to + offset, 1000).indexOf(' ');\n    }\n\n    checkColumn(0);\n    var pid = parseInt(line.substring(parsedhead[0].from + offset, parsedhead[0].to + offset2));\n    checkColumn(1);\n    var ppid = parseInt(line.substring(parsedhead[1].from + offset, parsedhead[1].to + offset2));\n    checkColumn(2);\n    var pcpu = parseFloat(line.substring(parsedhead[2].from + offset, parsedhead[2].to + offset2).replace(/,/g, '.'));\n    checkColumn(3);\n    var pmem = parseFloat(line.substring(parsedhead[3].from + offset, parsedhead[3].to + offset2).replace(/,/g, '.'));\n    checkColumn(4);\n    var priority = parseInt(line.substring(parsedhead[4].from + offset, parsedhead[4].to + offset2));\n    checkColumn(5);\n    var vsz = parseInt(line.substring(parsedhead[5].from + offset, parsedhead[5].to + offset2));\n    checkColumn(6);\n    var rss = parseInt(line.substring(parsedhead[6].from + offset, parsedhead[6].to + offset2));\n    checkColumn(7);\n    var nice = parseInt(line.substring(parsedhead[7].from + offset, parsedhead[7].to + offset2)) || 0;\n    checkColumn(8);\n    var started = parseTimeUnix(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim());\n    checkColumn(9);\n    var state = line.substring(parsedhead[9].from + offset, parsedhead[9].to + offset2).trim();\n    state = state[0] === 'R' ? 'running' : state[0] === 'S' ? 'sleeping' : state[0] === 'T' ? 'stopped' : state[0] === 'W' ? 'paging' : state[0] === 'X' ? 'dead' : state[0] === 'Z' ? 'zombie' : state[0] === 'D' || state[0] === 'U' ? 'blocked' : 'unknown';\n    checkColumn(10);\n    var tty = line.substring(parsedhead[10].from + offset, parsedhead[10].to + offset2).trim();\n    if (tty === '?' || tty === '??') tty = '';\n    checkColumn(11);\n    var user = line.substring(parsedhead[11].from + offset, parsedhead[11].to + offset2).trim();\n    checkColumn(12);\n    var command = line.substring(parsedhead[12].from + offset, parsedhead[12].to + offset2).trim().replace(/\\[/g, '').replace(/]/g, '');\n    return {\n      pid: pid,\n      parentPid: ppid,\n      name: _linux ? getName(command) : command,\n      pcpu: pcpu,\n      pcpuu: 0,\n      pcpus: 0,\n      pmem: pmem,\n      priority: priority,\n      mem_vsz: vsz,\n      mem_rss: rss,\n      nice: nice,\n      started: started,\n      state: state,\n      tty: tty,\n      user: user,\n      command: command\n    };\n  }\n\n  function parseProcesses(lines) {\n    var result = [];\n\n    if (lines.length > 1) {\n      var head = lines[0];\n      parsedhead = util.parseHead(head, 8);\n      lines.shift();\n      lines.forEach(function (line) {\n        if (line.trim() !== '') {\n          result.push(parseLine(line));\n        }\n      });\n    }\n\n    return result;\n  }\n\n  function parseProcesses2(lines) {\n    function formatDateTime(time) {\n      var month = ('0' + (time.getMonth() + 1).toString()).substr(-2);\n      var year = time.getFullYear().toString();\n      var day = ('0' + time.getDay().toString()).substr(-2);\n      var hours = time.getHours().toString();\n      var mins = time.getMinutes().toString();\n      var secs = ('0' + time.getSeconds().toString()).substr(-2);\n      return year + '-' + month + '-' + day + ' ' + hours + ':' + mins + ':' + secs;\n    }\n\n    var result = [];\n    lines.forEach(function (line) {\n      if (line.trim() !== '') {\n        line = line.trim().replace(/ +/g, ' ').replace(/,+/g, '.');\n        var parts = line.split(' ');\n        var command = parts.slice(9).join(' ');\n        var pmem = parseFloat((1.0 * parseInt(parts[3]) * 1024 / os.totalmem()).toFixed(1));\n        var elapsed_parts = parts[5].split(':');\n        var started = formatDateTime(new Date(Date.now() - (elapsed_parts.length > 1 ? (elapsed_parts[0] * 60 + elapsed_parts[1]) * 1000 : elapsed_parts[0] * 1000)));\n        result.push({\n          pid: parseInt(parts[0]),\n          parentPid: parseInt(parts[1]),\n          name: getName(command),\n          pcpu: 0,\n          pcpuu: 0,\n          pcpus: 0,\n          pmem: pmem,\n          priority: 0,\n          mem_vsz: parseInt(parts[2]),\n          mem_rss: parseInt(parts[3]),\n          nice: parseInt(parts[4]),\n          started: started,\n          state: parts[6] === 'R' ? 'running' : parts[6] === 'S' ? 'sleeping' : parts[6] === 'T' ? 'stopped' : parts[6] === 'W' ? 'paging' : parts[6] === 'X' ? 'dead' : parts[6] === 'Z' ? 'zombie' : parts[6] === 'D' || parts[6] === 'U' ? 'blocked' : 'unknown',\n          tty: parts[7],\n          user: parts[8],\n          command: command\n        });\n      }\n    });\n    return result;\n  }\n\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      var result = {\n        all: 0,\n        running: 0,\n        blocked: 0,\n        sleeping: 0,\n        unknown: 0,\n        list: []\n      };\n      var cmd = '';\n\n      if (_processes_cpu.ms && Date.now() - _processes_cpu.ms >= 500 || _processes_cpu.ms === 0) {\n        if (_linux || _freebsd || _openbsd || _darwin || _sunos) {\n          if (_linux) cmd = 'export LC_ALL=C; ps -axo pid:11,ppid:11,pcpu:6,pmem:6,pri:5,vsz:11,rss:11,ni:5,lstart:30,state:5,tty:15,user:20,command; unset LC_ALL';\n          if (_freebsd || _openbsd) cmd = 'export LC_ALL=C; ps -axo pid,ppid,pcpu,pmem,pri,vsz,rss,ni,lstart,state,tty,user,command; unset LC_ALL';\n          if (_darwin) cmd = 'export LC_ALL=C; ps -acxo pid,ppid,pcpu,pmem,pri,vsz,rss,nice,lstart,state,tty,user,command -r; unset LC_ALL';\n          if (_sunos) cmd = 'ps -Ao pid,ppid,pcpu,pmem,pri,vsz,rss,nice,stime,s,tty,user,comm';\n          exec(cmd, {\n            maxBuffer: 1024 * 2000\n          }, function (error, stdout) {\n            if (!error) {\n              result.list = parseProcesses(stdout.toString().split('\\n'));\n              result.all = result.list.length;\n              result.running = result.list.filter(function (e) {\n                return e.state === 'running';\n              }).length;\n              result.blocked = result.list.filter(function (e) {\n                return e.state === 'blocked';\n              }).length;\n              result.sleeping = result.list.filter(function (e) {\n                return e.state === 'sleeping';\n              }).length;\n\n              if (_linux) {\n                // calc process_cpu - ps is not accurate in linux!\n                cmd = 'cat /proc/stat | grep \"cpu \"';\n\n                for (var i = 0; i < result.list.length; i++) {\n                  cmd += ';cat /proc/' + result.list[i].pid + '/stat';\n                }\n\n                exec(cmd, {\n                  maxBuffer: 1024 * 2000\n                }, function (error, stdout) {\n                  var curr_processes = stdout.toString().split('\\n'); // first line (all - /proc/stat)\n\n                  var all = parseProcStat(curr_processes.shift()); // process\n\n                  var list_new = {};\n                  var resultProcess = {};\n\n                  for (var _i3 = 0; _i3 < curr_processes.length; _i3++) {\n                    resultProcess = calcProcStatLinux(curr_processes[_i3], all, _processes_cpu);\n\n                    if (resultProcess.pid) {\n                      // store pcpu in outer array\n                      var listPos = result.list.map(function (e) {\n                        return e.pid;\n                      }).indexOf(resultProcess.pid);\n\n                      if (listPos >= 0) {\n                        result.list[listPos].pcpu = resultProcess.pcpuu + resultProcess.pcpus;\n                        result.list[listPos].pcpuu = resultProcess.pcpuu;\n                        result.list[listPos].pcpus = resultProcess.pcpus;\n                      } // save new values\n\n\n                      list_new[resultProcess.pid] = {\n                        pcpuu: resultProcess.pcpuu,\n                        pcpus: resultProcess.pcpus,\n                        utime: resultProcess.utime,\n                        stime: resultProcess.stime,\n                        cutime: resultProcess.cutime,\n                        cstime: resultProcess.cstime\n                      };\n                    }\n                  } // store old values\n\n\n                  _processes_cpu.all = all;\n                  _processes_cpu.list = list_new;\n                  _processes_cpu.ms = Date.now() - _processes_cpu.ms;\n                  _processes_cpu.result = result;\n\n                  if (callback) {\n                    callback(result);\n                  }\n\n                  resolve(result);\n                });\n              } else {\n                if (callback) {\n                  callback(result);\n                }\n\n                resolve(result);\n              }\n            } else {\n              cmd = 'ps -o pid,ppid,vsz,rss,nice,etime,stat,tty,user,comm';\n\n              if (_sunos) {\n                cmd = 'ps -o pid,ppid,vsz,rss,nice,etime,s,tty,user,comm';\n              }\n\n              exec(cmd, {\n                maxBuffer: 1024 * 2000\n              }, function (error, stdout) {\n                if (!error) {\n                  var lines = stdout.toString().split('\\n');\n                  lines.shift();\n                  result.list = parseProcesses2(lines);\n                  result.all = result.list.length;\n                  result.running = result.list.filter(function (e) {\n                    return e.state === 'running';\n                  }).length;\n                  result.blocked = result.list.filter(function (e) {\n                    return e.state === 'blocked';\n                  }).length;\n                  result.sleeping = result.list.filter(function (e) {\n                    return e.state === 'sleeping';\n                  }).length;\n\n                  if (callback) {\n                    callback(result);\n                  }\n\n                  resolve(result);\n                } else {\n                  if (callback) {\n                    callback(result);\n                  }\n\n                  resolve(result);\n                }\n              });\n            }\n          });\n        }\n\n        if (_windows) {\n          try {\n            exec(util.getWmic() + ' process get /value', util.execOptsWin, function (error, stdout) {\n              if (!error) {\n                var processSections = stdout.split(/\\n\\s*\\n/);\n                var procs = [];\n                var procStats = [];\n                var list_new = {};\n                var allcpuu = 0;\n                var allcpus = 0;\n\n                for (var i = 0; i < processSections.length; i++) {\n                  if (processSections[i].trim() !== '') {\n                    var lines = processSections[i].trim().split('\\r\\n');\n                    var pid = parseInt(util.getValue(lines, 'ProcessId', '=', true), 10);\n                    var parentPid = parseInt(util.getValue(lines, 'ParentProcessId', '=', true), 10);\n                    var statusValue = util.getValue(lines, 'ExecutionState', '=');\n                    var name = util.getValue(lines, 'Caption', '=', true);\n                    var commandLine = util.getValue(lines, 'CommandLine', '=', true);\n                    var utime = parseInt(util.getValue(lines, 'UserModeTime', '=', true), 10);\n                    var stime = parseInt(util.getValue(lines, 'KernelModeTime', '=', true), 10);\n                    var mem = parseInt(util.getValue(lines, 'WorkingSetSize', '=', true), 10);\n                    allcpuu = allcpuu + utime;\n                    allcpus = allcpus + stime;\n                    result.all++;\n\n                    if (!statusValue) {\n                      result.unknown++;\n                    }\n\n                    if (statusValue === '3') {\n                      result.running++;\n                    }\n\n                    if (statusValue === '4' || statusValue === '5') {\n                      result.blocked++;\n                    }\n\n                    procStats.push({\n                      pid: pid,\n                      utime: utime,\n                      stime: stime,\n                      pcpu: 0,\n                      pcpuu: 0,\n                      pcpus: 0\n                    });\n                    procs.push({\n                      pid: pid,\n                      parentPid: parentPid,\n                      name: name,\n                      pcpu: 0,\n                      pcpuu: 0,\n                      pcpus: 0,\n                      pmem: mem / os.totalmem() * 100,\n                      priority: parseInt(util.getValue(lines, 'Priority', '=', true), 10),\n                      mem_vsz: parseInt(util.getValue(lines, 'PageFileUsage', '=', true), 10),\n                      mem_rss: Math.floor(parseInt(util.getValue(lines, 'WorkingSetSize', '=', true), 10) / 1024),\n                      nice: 0,\n                      started: parseTimeWin(util.getValue(lines, 'CreationDate', '=', true)),\n                      state: !statusValue ? _winStatusValues[0] : _winStatusValues[statusValue],\n                      tty: '',\n                      user: '',\n                      command: commandLine || name\n                    });\n                  }\n                }\n\n                result.sleeping = result.all - result.running - result.blocked - result.unknown;\n                result.list = procs;\n\n                for (var _i4 = 0; _i4 < procStats.length; _i4++) {\n                  var resultProcess = calcProcStatWin(procStats[_i4], allcpuu + allcpus, _processes_cpu); // store pcpu in outer array\n\n                  var listPos = result.list.map(function (e) {\n                    return e.pid;\n                  }).indexOf(resultProcess.pid);\n\n                  if (listPos >= 0) {\n                    result.list[listPos].pcpu = resultProcess.pcpuu + resultProcess.pcpus;\n                    result.list[listPos].pcpuu = resultProcess.pcpuu;\n                    result.list[listPos].pcpus = resultProcess.pcpus;\n                  } // save new values\n\n\n                  list_new[resultProcess.pid] = {\n                    pcpuu: resultProcess.pcpuu,\n                    pcpus: resultProcess.pcpus,\n                    utime: resultProcess.utime,\n                    stime: resultProcess.stime\n                  };\n                } // store old values\n\n\n                _processes_cpu.all = allcpuu + allcpus;\n                _processes_cpu.list = list_new;\n                _processes_cpu.ms = Date.now() - _processes_cpu.ms;\n                _processes_cpu.result = result;\n              }\n\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            });\n          } catch (e) {\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          }\n        }\n      } else {\n        if (callback) {\n          callback(_processes_cpu.result);\n        }\n\n        resolve(_processes_cpu.result);\n      }\n    });\n  });\n}\n\nexports.processes = processes; // --------------------------\n// PS - process load\n// get detailed information about a certain process\n// (PID, CPU-Usage %, Mem-Usage %)\n\nfunction processLoad(proc, callback) {\n  // fallback - if only callback is given\n  if (util.isFunction(proc) && !callback) {\n    callback = proc;\n    proc = '';\n  }\n\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      var result = {\n        'proc': proc,\n        'pid': -1,\n        'cpu': 0,\n        'mem': 0\n      };\n\n      if (proc) {\n        if (_windows) {\n          try {\n            exec(util.getWmic() + ' process get /value', util.execOptsWin, function (error, stdout) {\n              if (!error) {\n                var processSections = stdout.split(/\\n\\s*\\n/);\n                var procStats = [];\n                var list_new = {};\n                var allcpuu = 0;\n                var allcpus = 0;\n\n                for (var i = 0; i < processSections.length; i++) {\n                  if (processSections[i].trim() !== '') {\n                    var lines = processSections[i].trim().split('\\r\\n');\n                    var pid = parseInt(util.getValue(lines, 'ProcessId', '=', true), 10);\n                    var name = util.getValue(lines, 'Caption', '=', true);\n                    var utime = parseInt(util.getValue(lines, 'UserModeTime', '=', true), 10);\n                    var stime = parseInt(util.getValue(lines, 'KernelModeTime', '=', true), 10);\n                    var mem = parseInt(util.getValue(lines, 'WorkingSetSize', '=', true), 10);\n                    allcpuu = allcpuu + utime;\n                    allcpus = allcpus + stime;\n                    procStats.push({\n                      pid: pid,\n                      utime: utime,\n                      stime: stime,\n                      pcpu: 0,\n                      pcpuu: 0,\n                      pcpus: 0\n                    });\n\n                    if (name.toLowerCase().indexOf(proc.toLowerCase()) >= 0) {\n                      if (result.pid === -1) {\n                        result = {\n                          proc: name,\n                          pid: pid,\n                          pids: [pid],\n                          cpu: 0,\n                          mem: mem / os.totalmem() * 100\n                        };\n                      } else {\n                        result.pids.push(pid);\n                        result.mem += mem / os.totalmem() * 100;\n                      }\n                    }\n                  }\n                }\n\n                for (var _i5 = 0; _i5 < procStats.length; _i5++) {\n                  var resultProcess = calcProcStatWin(procStats[_i5], allcpuu + allcpus, _process_cpu); // store pcpu in outer array\n\n                  var listPos = result.pids.indexOf(resultProcess.pid);\n\n                  if (listPos >= 0) {\n                    result.cpu = resultProcess.pcpuu + resultProcess.pcpus;\n                  } // save new values\n\n\n                  list_new[resultProcess.pid] = {\n                    pcpuu: resultProcess.pcpuu,\n                    pcpus: resultProcess.pcpus,\n                    utime: resultProcess.utime,\n                    stime: resultProcess.stime\n                  };\n                } // store old values\n\n\n                _process_cpu.all = allcpuu + allcpus;\n                _process_cpu.list = list_new;\n                _process_cpu.ms = Date.now() - _process_cpu.ms;\n                _process_cpu.result = result;\n\n                if (callback) {\n                  callback(result);\n                }\n\n                resolve(result);\n              }\n            });\n          } catch (e) {\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          }\n        }\n\n        if (_darwin || _linux) {\n          exec('ps -axo pid,pcpu,pmem,comm | grep -i ' + proc + ' | grep -v grep', {\n            maxBuffer: 1024 * 2000\n          }, function (error, stdout) {\n            if (!error) {\n              var lines = stdout.toString().split('\\n');\n              var pid = 0;\n              var pids = [];\n              var cpu = 0;\n              var mem = 0;\n              lines.forEach(function (line) {\n                var data = line.trim().replace(/ +/g, ' ').split(' ');\n\n                if (data.length > 3) {\n                  pid = !pid ? parseInt(data[0]) : 0;\n                  pids.push(parseInt(data[0], 10));\n                  cpu = cpu + parseFloat(data[1].replace(',', '.'));\n                  mem = mem + parseFloat(data[2].replace(',', '.'));\n                }\n              });\n              result = {\n                'proc': proc,\n                'pid': pid,\n                'pids': pids,\n                'cpu': parseFloat((cpu / lines.length).toFixed(2)),\n                'mem': parseFloat((mem / lines.length).toFixed(2))\n              };\n\n              if (_linux) {\n                // calc process_cpu - ps is not accurate in linux!\n                var cmd = 'cat /proc/stat | grep \"cpu \"';\n\n                for (var i = 0; i < result.pids.length; i++) {\n                  cmd += ';cat /proc/' + result.pids[i] + '/stat';\n                }\n\n                exec(cmd, {\n                  maxBuffer: 1024 * 2000\n                }, function (error, stdout) {\n                  var curr_processes = stdout.toString().split('\\n'); // first line (all - /proc/stat)\n\n                  var all = parseProcStat(curr_processes.shift()); // process\n\n                  var list_new = {};\n                  var resultProcess = {};\n                  result.cpu = 0;\n\n                  for (var _i6 = 0; _i6 < curr_processes.length; _i6++) {\n                    resultProcess = calcProcStatLinux(curr_processes[_i6], all, _process_cpu);\n\n                    if (resultProcess.pid) {\n                      // store pcpu in outer result\n                      result.cpu += resultProcess.pcpuu + resultProcess.pcpus; // save new values\n\n                      list_new[resultProcess.pid] = {\n                        pcpuu: resultProcess.pcpuu,\n                        pcpus: resultProcess.pcpus,\n                        utime: resultProcess.utime,\n                        stime: resultProcess.stime,\n                        cutime: resultProcess.cutime,\n                        cstime: resultProcess.cstime\n                      };\n                    }\n                  }\n\n                  result.cpu = Math.round(result.cpu * 100) / 100;\n                  _process_cpu.all = all;\n                  _process_cpu.list = list_new;\n                  _process_cpu.ms = Date.now() - _process_cpu.ms;\n                  _process_cpu.result = result;\n\n                  if (callback) {\n                    callback(result);\n                  }\n\n                  resolve(result);\n                });\n              } else {\n                if (callback) {\n                  callback(result);\n                }\n\n                resolve(result);\n              }\n            } else {\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            }\n          });\n        }\n      }\n    });\n  });\n}\n\nexports.processLoad = processLoad;","map":null,"metadata":{},"sourceType":"script"}