{"ast":null,"code":"'use strict'; // ==================================================================================\n// filesystem.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2018\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 8. File System\n// ----------------------------------------------------------------------------------\n\nvar exec = require('child_process').exec;\n\nvar execSync = require('child_process').execSync;\n\nvar util = require('./util');\n\nvar _platform = process.platform;\n\nvar _linux = _platform === 'linux';\n\nvar _darwin = _platform === 'darwin';\n\nvar _windows = _platform === 'win32';\n\nvar _freebsd = _platform === 'freebsd';\n\nvar _openbsd = _platform === 'openbsd';\n\nvar _sunos = _platform === 'sunos';\n\nvar NOT_SUPPORTED = 'not supported';\nvar _fs_speed = {};\nvar _disk_io = {}; // --------------------------\n// FS - mounted file systems\n\nfunction fsSize(callback) {\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      var data = [];\n\n      if (_linux || _freebsd || _openbsd || _darwin) {\n        var cmd = '';\n        if (_darwin) cmd = 'df -lkP | grep ^/';\n        if (_linux) cmd = 'df -lkPT | grep ^/';\n        if (_freebsd || _openbsd) cmd = 'df -lkPT';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            var lines = stdout.toString().split('\\n'); //lines.splice(0, 1);\n\n            lines.forEach(function (line) {\n              if (line !== '') {\n                line = line.replace(/ +/g, ' ').split(' ');\n\n                if (line && line[0].startsWith('/') || line[6] && line[6] === '/') {\n                  data.push({\n                    'fs': line[0],\n                    'type': _linux || _freebsd || _openbsd ? line[1] : 'HFS',\n                    'size': parseInt(_linux || _freebsd || _openbsd ? line[2] : line[1]) * 1024,\n                    'used': parseInt(_linux || _freebsd || _openbsd ? line[3] : line[2]) * 1024,\n                    'use': parseFloat((100.0 * (_linux || _freebsd || _openbsd ? line[3] : line[2]) / (_linux || _freebsd || _openbsd ? line[2] : line[1])).toFixed(2)),\n                    'mount': line[line.length - 1]\n                  });\n                }\n              }\n            });\n          }\n\n          if (callback) {\n            callback(data);\n          }\n\n          resolve(data);\n        });\n      }\n\n      if (_sunos) {\n        if (callback) {\n          callback(data);\n        }\n\n        resolve(data);\n      }\n\n      if (_windows) {\n        try {\n          exec(util.getWmic() + ' logicaldisk get Caption,FileSystem,FreeSpace,Size', util.execOptsWin, function (error, stdout) {\n            var lines = stdout.split('\\r\\n').filter(function (line) {\n              return line.trim() !== '';\n            }).filter(function (line, idx) {\n              return idx > 0;\n            });\n            lines.forEach(function (line) {\n              if (line !== '') {\n                line = line.trim().split(/\\s\\s+/);\n                data.push({\n                  'fs': line[0],\n                  'type': line[1],\n                  'size': line[3],\n                  'used': parseInt(line[3]) - parseInt(line[2]),\n                  'use': parseFloat(100.0 * (parseInt(line[3]) - parseInt(line[2])) / parseInt(line[3])),\n                  'mount': line[0]\n                });\n              }\n            });\n\n            if (callback) {\n              callback(data);\n            }\n\n            resolve(data);\n          });\n        } catch (e) {\n          if (callback) {\n            callback(data);\n          }\n\n          resolve(data);\n        }\n      }\n    });\n  });\n}\n\nexports.fsSize = fsSize; // --------------------------\n// disks\n\nfunction parseBytes(s) {\n  return parseInt(s.substr(s.indexOf(' (') + 2, s.indexOf(' Bytes)') - 10));\n}\n\nfunction parseDevices(lines) {\n  var devices = [];\n  var i = 0;\n  lines.forEach(function (line) {\n    if (line.length > 0) {\n      if (line[0] === '*') {\n        i++;\n      } else {\n        var parts = line.split(':');\n\n        if (parts.length > 1) {\n          if (!devices[i]) devices[i] = {\n            name: '',\n            identifier: '',\n            type: 'disk',\n            fstype: '',\n            mount: '',\n            size: 0,\n            physical: 'HDD',\n            uuid: '',\n            label: '',\n            model: '',\n            serial: '',\n            removable: false,\n            protocol: ''\n          };\n          parts[0] = parts[0].trim().toUpperCase().replace(/ +/g, '');\n          parts[1] = parts[1].trim();\n          if ('DEVICEIDENTIFIER' === parts[0]) devices[i].identifier = parts[1];\n          if ('DEVICENODE' === parts[0]) devices[i].name = parts[1];\n\n          if ('VOLUMENAME' === parts[0]) {\n            if (parts[1].indexOf('Not applicable') === -1) devices[i].label = parts[1];\n          }\n\n          if ('PROTOCOL' === parts[0]) devices[i].protocol = parts[1];\n          if ('DISKSIZE' === parts[0]) devices[i].size = parseBytes(parts[1]);\n          if ('FILESYSTEMPERSONALITY' === parts[0]) devices[i].fstype = parts[1];\n          if ('MOUNTPOINT' === parts[0]) devices[i].mount = parts[1];\n          if ('VOLUMEUUID' === parts[0]) devices[i].uuid = parts[1];\n          if ('READ-ONLYMEDIA' === parts[0] && parts[1] === 'Yes') devices[i].physical = 'CD/DVD';\n          if ('SOLIDSTATE' === parts[0] && parts[1] === 'Yes') devices[i].physical = 'SSD';\n          if ('VIRTUAL' === parts[0]) devices[i].type = 'virtual';\n          if ('REMOVABLEMEDIA' === parts[0]) devices[i].removable = parts[1] === 'Removable';\n          if ('PARTITIONTYPE' === parts[0]) devices[i].type = 'part';\n          if ('DEVICE/MEDIANAME' === parts[0]) devices[i].model = parts[1];\n        }\n      }\n    }\n  });\n  return devices;\n}\n\nfunction parseBlk(lines) {\n  var data = [];\n  lines.filter(function (line) {\n    return line !== '';\n  }).forEach(function (line) {\n    line = util.decodeEscapeSequence(line);\n    line = line.replace(/\\\\/g, '\\\\\\\\');\n    var disk = JSON.parse(line);\n    data.push({\n      'name': disk.name,\n      'type': disk.type,\n      'fstype': disk.fstype,\n      'mount': disk.mountpoint,\n      'size': parseInt(disk.size),\n      'physical': disk.type === 'disk' ? disk.rota === '0' ? 'SSD' : 'HDD' : disk.type === 'rom' ? 'CD/DVD' : '',\n      'uuid': disk.uuid,\n      'label': disk.label,\n      'model': disk.model,\n      'serial': disk.serial,\n      'removable': disk.rm === '1',\n      'protocol': disk.tran\n    });\n  });\n  data = util.unique(data);\n  data = util.sortByKey(data, ['type', 'name']);\n  return data;\n}\n\nfunction blkStdoutToObject(stdout) {\n  return stdout.toString().replace(/NAME=/g, '{\"name\":').replace(/FSTYPE=/g, ',\"fstype\":').replace(/TYPE=/g, ',\"type\":').replace(/SIZE=/g, ',\"size\":').replace(/MOUNTPOINT=/g, ',\"mountpoint\":').replace(/UUID=/g, ',\"uuid\":').replace(/ROTA=/g, ',\"rota\":').replace(/RO=/g, ',\"ro\":').replace(/RM=/g, ',\"rm\":').replace(/TRAN=/g, ',\"tran\":').replace(/SERIAL=/g, ',\"serial\":').replace(/LABEL=/g, ',\"label\":').replace(/MODEL=/g, ',\"model\":').replace(/OWNER=/g, ',\"owner\":').replace(/\\n/g, '}\\n');\n}\n\nfunction blockDevices(callback) {\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      var data = [];\n\n      if (_linux) {\n        // see https://wiki.ubuntuusers.de/lsblk/\n        // exec(\"lsblk -bo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,TRAN,SERIAL,LABEL,MODEL,OWNER,GROUP,MODE,ALIGNMENT,MIN-IO,OPT-IO,PHY-SEC,LOG-SEC,SCHED,RQ-SIZE,RA,WSAME\", function (error, stdout) {\n        exec('lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER', function (error, stdout) {\n          if (!error) {\n            var lines = blkStdoutToObject(stdout).split('\\n');\n            data = parseBlk(lines);\n\n            if (callback) {\n              callback(data);\n            }\n\n            resolve(data);\n          } else {\n            exec('lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER', function (error, stdout) {\n              if (!error) {\n                var _lines = blkStdoutToObject(stdout).split('\\n');\n\n                data = parseBlk(_lines);\n              }\n\n              if (callback) {\n                callback(data);\n              }\n\n              resolve(data);\n            });\n          }\n        });\n      }\n\n      if (_darwin) {\n        exec('diskutil info -all', function (error, stdout) {\n          if (!error) {\n            var lines = stdout.toString().split('\\n'); // parse lines into temp array of devices\n\n            data = parseDevices(lines);\n          }\n\n          if (callback) {\n            callback(data);\n          }\n\n          resolve(data);\n        });\n      }\n\n      if (_sunos) {\n        if (callback) {\n          callback(data);\n        }\n\n        resolve(data);\n      }\n\n      if (_windows) {\n        var drivetypes = ['Unknown', 'NoRoot', 'Removable', 'Local', 'Network', 'CD/DVD', 'RAM'];\n\n        try {\n          util.execWin(util.getWmic() + ' logicaldisk get Caption,Description,DeviceID,DriveType,FileSystem,FreeSpace,Name,Size,VolumeName,VolumeSerialNumber /value', util.execOptsWin, function (error, stdout) {\n            if (!error) {\n              var devices = stdout.toString().split(/\\n\\s*\\n/);\n              devices.forEach(function (device) {\n                var lines = device.split('\\r\\n');\n                var drivetype = util.getValue(lines, 'drivetype', '=');\n\n                if (drivetype) {\n                  data.push({\n                    name: util.getValue(lines, 'name', '='),\n                    identifier: util.getValue(lines, 'caption', '='),\n                    type: 'disk',\n                    fstype: util.getValue(lines, 'filesystem', '=').toLowerCase(),\n                    mount: util.getValue(lines, 'caption', '='),\n                    size: util.getValue(lines, 'size', '='),\n                    physical: drivetype >= 0 && drivetype <= 6 ? drivetypes[drivetype] : drivetypes[0],\n                    uuid: util.getValue(lines, 'volumeserialnumber', '='),\n                    label: util.getValue(lines, 'volumename', '='),\n                    model: '',\n                    serial: util.getValue(lines, 'volumeserialnumber', '='),\n                    removable: drivetype === '2',\n                    protocol: ''\n                  });\n                }\n              });\n            }\n\n            if (callback) {\n              callback(data);\n            }\n\n            resolve(data);\n          });\n        } catch (e) {\n          if (callback) {\n            callback(data);\n          }\n\n          resolve(data);\n        }\n      }\n    });\n  });\n}\n\nexports.blockDevices = blockDevices; // --------------------------\n// FS - speed\n\nfunction calcFsSpeed(rx, wx) {\n  var result = {\n    rx: 0,\n    wx: 0,\n    tx: 0,\n    rx_sec: -1,\n    wx_sec: -1,\n    tx_sec: -1,\n    ms: 0\n  };\n\n  if (_fs_speed && _fs_speed.ms) {\n    result.rx = rx;\n    result.wx = wx;\n    result.tx = result.rx + result.wx;\n    result.ms = Date.now() - _fs_speed.ms;\n    result.rx_sec = (result.rx - _fs_speed.bytes_read) / (result.ms / 1000);\n    result.wx_sec = (result.wx - _fs_speed.bytes_write) / (result.ms / 1000);\n    result.tx_sec = result.rx_sec + result.wx_sec;\n    _fs_speed.rx_sec = result.rx_sec;\n    _fs_speed.wx_sec = result.wx_sec;\n    _fs_speed.tx_sec = result.tx_sec;\n    _fs_speed.bytes_read = result.rx;\n    _fs_speed.bytes_write = result.wx;\n    _fs_speed.bytes_overall = result.rx + result.wx;\n    _fs_speed.ms = Date.now();\n    _fs_speed.last_ms = result.ms;\n  } else {\n    result.rx = rx;\n    result.wx = wx;\n    result.tx = result.rx + result.wx;\n    _fs_speed.rx_sec = -1;\n    _fs_speed.wx_sec = -1;\n    _fs_speed.tx_sec = -1;\n    _fs_speed.bytes_read = result.rx;\n    _fs_speed.bytes_write = result.wx;\n    _fs_speed.bytes_overall = result.rx + result.wx;\n    _fs_speed.ms = Date.now();\n    _fs_speed.last_ms = 0;\n  }\n\n  return result;\n}\n\nfunction fsStats(callback) {\n  return new Promise(function (resolve, reject) {\n    process.nextTick(function () {\n      if (_windows) {\n        var error = new Error(NOT_SUPPORTED);\n\n        if (callback) {\n          callback(NOT_SUPPORTED);\n        }\n\n        reject(error);\n      }\n\n      var result = {\n        rx: 0,\n        wx: 0,\n        tx: 0,\n        rx_sec: -1,\n        wx_sec: -1,\n        tx_sec: -1,\n        ms: 0\n      };\n      var rx = 0;\n      var wx = 0;\n\n      if (_fs_speed && !_fs_speed.ms || _fs_speed && _fs_speed.ms && Date.now() - _fs_speed.ms >= 500) {\n        if (_linux) {\n          // exec(\"df -k | grep /dev/\", function(error, stdout) {\n          exec('lsblk | grep /', function (error, stdout) {\n            if (!error) {\n              var lines = stdout.toString().split('\\n');\n              var fs_filter = [];\n              lines.forEach(function (line) {\n                if (line !== '') {\n                  line = line.replace(/[├─│└]+/g, '').trim().split(' ');\n                  if (fs_filter.indexOf(line[0]) === -1) fs_filter.push(line[0]);\n                }\n              });\n              var output = fs_filter.join('|');\n              exec('cat /proc/diskstats | egrep \"' + output + '\"', function (error, stdout) {\n                if (!error) {\n                  var _lines2 = stdout.toString().split('\\n');\n\n                  _lines2.forEach(function (line) {\n                    line = line.trim();\n\n                    if (line !== '') {\n                      line = line.replace(/ +/g, ' ').split(' ');\n                      rx += parseInt(line[5]) * 512;\n                      wx += parseInt(line[9]) * 512;\n                    }\n                  });\n\n                  result = calcFsSpeed(rx, wx);\n                }\n\n                if (callback) {\n                  callback(result);\n                }\n\n                resolve(result);\n              });\n            } else {\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            }\n          });\n        }\n\n        if (_darwin) {\n          exec('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n \"/IOBlockStorageDriver/,/Statistics/p\" | grep \"Statistics\" | tr -cd \"01234567890,\\n\"', function (error, stdout) {\n            if (!error) {\n              var lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                line = line.trim();\n\n                if (line !== '') {\n                  line = line.split(',');\n                  rx += parseInt(line[2]);\n                  wx += parseInt(line[9]);\n                }\n              });\n              result = calcFsSpeed(rx, wx);\n            }\n\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          });\n        }\n      } else {\n        result.ms = _fs_speed.last_ms;\n        result.rx = _fs_speed.bytes_read;\n        result.wx = _fs_speed.bytes_write;\n        result.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;\n        result.rx_sec = _fs_speed.rx_sec;\n        result.wx_sec = _fs_speed.wx_sec;\n        result.tx_sec = _fs_speed.tx_sec;\n\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.fsStats = fsStats;\n\nfunction calcDiskIO(rIO, wIO) {\n  var result = {\n    rIO: 0,\n    wIO: 0,\n    tIO: 0,\n    rIO_sec: -1,\n    wIO_sec: -1,\n    tIO_sec: -1,\n    ms: 0\n  };\n\n  if (_disk_io && _disk_io.ms) {\n    result.rIO = rIO;\n    result.wIO = wIO;\n    result.tIO = rIO + wIO;\n    result.ms = Date.now() - _disk_io.ms;\n    result.rIO_sec = (result.rIO - _disk_io.rIO) / (result.ms / 1000);\n    result.wIO_sec = (result.wIO - _disk_io.wIO) / (result.ms / 1000);\n    result.tIO_sec = result.rIO_sec + result.wIO_sec;\n    _disk_io.rIO = rIO;\n    _disk_io.wIO = wIO;\n    _disk_io.rIO_sec = result.rIO_sec;\n    _disk_io.wIO_sec = result.wIO_sec;\n    _disk_io.tIO_sec = result.tIO_sec;\n    _disk_io.last_ms = result.ms;\n    _disk_io.ms = Date.now();\n  } else {\n    result.rIO = rIO;\n    result.wIO = wIO;\n    result.tIO = rIO + wIO;\n    _disk_io.rIO = rIO;\n    _disk_io.wIO = wIO;\n    _disk_io.rIO_sec = -1;\n    _disk_io.wIO_sec = -1;\n    _disk_io.tIO_sec = -1;\n    _disk_io.last_ms = 0;\n    _disk_io.ms = Date.now();\n  }\n\n  return result;\n}\n\nfunction disksIO(callback) {\n  return new Promise(function (resolve, reject) {\n    process.nextTick(function () {\n      if (_windows) {\n        var error = new Error(NOT_SUPPORTED);\n\n        if (callback) {\n          callback(NOT_SUPPORTED);\n        }\n\n        reject(error);\n      }\n\n      if (_sunos) {\n        var _error = new Error(NOT_SUPPORTED);\n\n        if (callback) {\n          callback(NOT_SUPPORTED);\n        }\n\n        reject(_error);\n      }\n\n      var result = {\n        rIO: 0,\n        wIO: 0,\n        tIO: 0,\n        rIO_sec: -1,\n        wIO_sec: -1,\n        tIO_sec: -1,\n        ms: 0\n      };\n      var rIO = 0;\n      var wIO = 0;\n\n      if (_disk_io && !_disk_io.ms || _disk_io && _disk_io.ms && Date.now() - _disk_io.ms >= 500) {\n        if (_linux || _freebsd || _openbsd) {\n          // prints Block layer statistics for all mounted volumes\n          // var cmd = \"for mount in `lsblk | grep / | sed -r 's/│ └─//' | cut -d ' ' -f 1`; do cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done\";\n          // var cmd = \"for mount in `lsblk | grep / | sed 's/[│└─├]//g' | awk '{$1=$1};1' | cut -d ' ' -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done\";\n          var cmd = 'for mount in `lsblk | grep \" disk \" | sed \"s/[│└─├]//g\" | awk \\'{$1=$1};1\\' | cut -d \" \" -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r \"s/ +/;/g\" | sed -r \"s/^;//\"; done';\n          exec(cmd, function (error, stdout) {\n            if (!error) {\n              var lines = stdout.split('\\n');\n              lines.forEach(function (line) {\n                // ignore empty lines\n                if (!line) return; // sum r/wIO of all disks to compute all disks IO\n\n                var stats = line.split(';');\n                rIO += parseInt(stats[0]);\n                wIO += parseInt(stats[4]);\n              });\n              result = calcDiskIO(rIO, wIO);\n\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            } else {\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            }\n          });\n        }\n\n        if (_darwin) {\n          exec('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n \"/IOBlockStorageDriver/,/Statistics/p\" | grep \"Statistics\" | tr -cd \"01234567890,\\n\"', function (error, stdout) {\n            if (!error) {\n              var lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                line = line.trim();\n\n                if (line !== '') {\n                  line = line.split(',');\n                  rIO += parseInt(line[10]);\n                  wIO += parseInt(line[0]);\n                }\n              });\n              result = calcDiskIO(rIO, wIO);\n            }\n\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          });\n        }\n      } else {\n        result.rIO = _disk_io.rIO;\n        result.wIO = _disk_io.wIO;\n        result.tIO = _disk_io.rIO + _disk_io.wIO;\n        result.ms = _disk_io.last_ms;\n        result.rIO_sec = _disk_io.rIO_sec;\n        result.wIO_sec = _disk_io.wIO_sec;\n        result.tIO_sec = _disk_io.tIO_sec;\n\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.disksIO = disksIO;\n\nfunction diskLayout(callback) {\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      var result = [];\n      var cmd = '';\n\n      if (_linux) {\n        exec('export LC_ALL=C; lshw -class disk; unset LC_ALL', function (error, stdout) {\n          if (!error) {\n            var devices = stdout.toString().split('*-');\n            devices.shift();\n            devices.forEach(function (device) {\n              var lines = device.split('\\n');\n              var mediumType = '';\n              var BSDName = util.getValue(lines, 'logical name', ':', true).trim();\n              var logical = util.getValue(lines, 'logical name', ':', true).trim().replace(/\\/dev\\//g, '');\n\n              try {\n                mediumType = execSync('cat /sys/block/' + logical + '/queue/rotational').toString().split('\\n')[0];\n              } catch (e) {\n                util.noop();\n              }\n\n              var sizeString = util.getValue(lines, 'size', ':', true).trim();\n\n              if (sizeString && lines.length > 0 && lines[0].trim() === 'disk') {\n                var sizeValue = sizeString.match(/\\(([^)]+)\\)/)[1];\n                result.push({\n                  type: mediumType === '0' ? 'SSD' : mediumType === '1' ? 'HD' : device.indexOf('SSD') > -1 ? 'SSD' : 'HD',\n                  // to be tested ... /sys/block/sda/queue/rotational\n                  name: util.getValue(lines, 'product:', ':', true),\n                  vendor: util.getValue(lines, 'vendor:', ':', true),\n                  size: parseInt(sizeValue, 10) * 1000 * 1000 * 1000 * (sizeValue.indexOf('T') >= 0 ? 1000 : 1),\n                  bytesPerSector: -1,\n                  totalCylinders: -1,\n                  totalHeads: -1,\n                  totalSectors: -1,\n                  totalTracks: -1,\n                  tracksPerCylinder: -1,\n                  sectorsPerTrack: -1,\n                  firmwareRevision: util.getValue(lines, 'version:', ':', true).trim(),\n                  serialNum: util.getValue(lines, 'serial:', ':', true).trim(),\n                  interfaceType: '',\n                  smartStatus: 'unknown',\n                  BSDName: BSDName\n                });\n                cmd = cmd + 'printf \"\\n' + BSDName + '|\"; smartctl -H ' + BSDName + ' | grep overall;';\n              }\n            });\n          }\n\n          if (cmd) {\n            cmd = cmd + 'printf \"\\n\"';\n            exec(cmd, function (error, stdout) {\n              var lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                if (line) {\n                  var parts = line.split('|');\n\n                  if (parts.length === 2) {\n                    var BSDName = parts[0];\n                    parts[1] = parts[1].trim();\n                    var parts2 = parts[1].split(':');\n\n                    if (parts2.length === 2) {\n                      parts2[1] = parts2[1].trim();\n                      var status = parts2[1].toLowerCase();\n\n                      for (var i = 0; i < result.length; i++) {\n                        if (result[i].BSDName === BSDName) {\n                          result[i].smartStatus = status === 'passed' ? 'Ok' : status === 'failed!' ? 'Predicted Failure' : 'unknown';\n                        }\n                      }\n                    }\n                  }\n                }\n              });\n\n              for (var i = 0; i < result.length; i++) {\n                delete result[i].BSDName;\n              }\n\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            });\n          } else {\n            for (var i = 0; i < result.length; i++) {\n              delete result[i].BSDName;\n            }\n\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          }\n        });\n      }\n\n      if (_freebsd || _openbsd) {\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n\n      if (_sunos) {\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n\n      if (_darwin) {\n        exec('system_profiler SPSerialATADataType SPNVMeDataType', function (error, stdout) {\n          if (!error) {\n            var parts = stdout.toString().split('NVMExpress:');\n            var devices = parts[0].split(' Physical Interconnect: ');\n            devices.shift();\n            devices.forEach(function (device) {\n              device = 'InterfaceType: ' + device;\n              var lines = device.split('\\n');\n              var mediumType = util.getValue(lines, 'Medium Type', ':', true).trim();\n              var sizeStr = util.getValue(lines, 'capacity', ':', true).trim();\n              var BSDName = util.getValue(lines, 'BSD Name', ':', true).trim();\n\n              if (sizeStr) {\n                var sizeValue = 0;\n\n                if (sizeStr.indexOf('(') >= 0) {\n                  sizeValue = parseInt(sizeStr.match(/\\(([^)]+)\\)/)[1].replace(/\\./g, '').replace(/,/g, ''));\n                }\n\n                if (!sizeValue) {\n                  sizeValue = parseInt(sizeStr);\n                }\n\n                if (sizeValue) {\n                  result.push({\n                    type: mediumType.startsWith('Solid') ? 'SSD' : 'HD',\n                    name: util.getValue(lines, 'Model', ':', true).trim(),\n                    vendor: '',\n                    size: sizeValue,\n                    bytesPerSector: -1,\n                    totalCylinders: -1,\n                    totalHeads: -1,\n                    totalSectors: -1,\n                    totalTracks: -1,\n                    tracksPerCylinder: -1,\n                    sectorsPerTrack: -1,\n                    firmwareRevision: util.getValue(lines, 'Revision', ':', true).trim(),\n                    serialNum: util.getValue(lines, 'Serial Number', ':', true).trim(),\n                    interfaceType: util.getValue(lines, 'InterfaceType', ':', true).trim(),\n                    smartStatus: 'unknown',\n                    BSDName: BSDName\n                  });\n                  cmd = cmd + 'printf \"\\n' + BSDName + '|\"; diskutil info /dev/' + BSDName + ' | grep SMART;';\n                }\n              }\n            });\n\n            if (parts.length > 1) {\n              var _devices = parts[1].split('\\n\\n          Capacity:');\n\n              _devices.shift();\n\n              _devices.forEach(function (device) {\n                device = '!Capacity: ' + device;\n                var lines = device.split('\\n');\n                var linkWidth = util.getValue(lines, 'link width', ':', true).trim();\n                var sizeStr = util.getValue(lines, '!capacity', ':', true).trim();\n                var BSDName = util.getValue(lines, 'BSD Name', ':', true).trim();\n\n                if (sizeStr) {\n                  var sizeValue = 0;\n\n                  if (sizeStr.indexOf('(') >= 0) {\n                    sizeValue = parseInt(sizeStr.match(/\\(([^)]+)\\)/)[1].replace(/\\./g, '').replace(/,/g, ''));\n                  }\n\n                  if (!sizeValue) {\n                    sizeValue = parseInt(sizeStr);\n                  }\n\n                  if (sizeValue) {\n                    result.push({\n                      type: 'NVMe',\n                      name: util.getValue(lines, 'Model', ':', true).trim(),\n                      vendor: '',\n                      size: sizeValue,\n                      bytesPerSector: -1,\n                      totalCylinders: -1,\n                      totalHeads: -1,\n                      totalSectors: -1,\n                      totalTracks: -1,\n                      tracksPerCylinder: -1,\n                      sectorsPerTrack: -1,\n                      firmwareRevision: util.getValue(lines, 'Revision', ':', true).trim(),\n                      serialNum: util.getValue(lines, 'Serial Number', ':', true).trim(),\n                      interfaceType: ('PCIe ' + linkWidth).trim(),\n                      smartStatus: 'unknown',\n                      BSDName: BSDName\n                    });\n                    cmd = cmd + 'printf \"\\n' + BSDName + '|\"; diskutil info /dev/' + BSDName + ' | grep SMART;';\n                  }\n                }\n              });\n            }\n          }\n\n          if (cmd) {\n            cmd = cmd + 'printf \"\\n\"';\n            exec(cmd, function (error, stdout) {\n              var lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                if (line) {\n                  var _parts = line.split('|');\n\n                  if (_parts.length === 2) {\n                    var BSDName = _parts[0];\n                    _parts[1] = _parts[1].trim();\n\n                    var parts2 = _parts[1].split(':');\n\n                    if (parts2.length === 2) {\n                      parts2[1] = parts2[1].trim();\n                      var status = parts2[1].toLowerCase();\n\n                      for (var i = 0; i < result.length; i++) {\n                        if (result[i].BSDName === BSDName) {\n                          result[i].smartStatus = status === 'not supported' ? 'not supported' : status === 'verified' ? 'Ok' : status === 'failing' ? 'Predicted Failure' : 'unknown';\n                        }\n                      }\n                    }\n                  }\n                }\n              });\n\n              for (var i = 0; i < result.length; i++) {\n                delete result[i].BSDName;\n              }\n\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            });\n          } else {\n            for (var i = 0; i < result.length; i++) {\n              delete result[i].BSDName;\n            }\n\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          }\n        });\n      }\n\n      if (_windows) {\n        try {\n          exec(util.getWmic() + ' diskdrive get /value', {\n            encoding: 'utf8',\n            windowsHide: true\n          }, function (error, stdout) {\n            if (!error) {\n              var devices = stdout.toString().split(/\\n\\s*\\n/);\n              devices.forEach(function (device) {\n                var lines = device.split('\\r\\n');\n                var size = util.getValue(lines, 'Size', '=').trim();\n                var status = util.getValue(lines, 'Status', '=').trim().toLowerCase();\n\n                if (size) {\n                  result.push({\n                    type: device.indexOf('SSD') > -1 ? 'SSD' : 'HD',\n                    // just a starting point ... better: MSFT_PhysicalDisk - Media Type ... see below\n                    name: util.getValue(lines, 'Caption', '='),\n                    vendor: util.getValue(lines, 'Manufacturer', '='),\n                    size: parseInt(size),\n                    bytesPerSector: parseInt(util.getValue(lines, 'BytesPerSector', '=')),\n                    totalCylinders: parseInt(util.getValue(lines, 'TotalCylinders', '=')),\n                    totalHeads: parseInt(util.getValue(lines, 'TotalHeads', '=')),\n                    totalSectors: parseInt(util.getValue(lines, 'TotalSectors', '=')),\n                    totalTracks: parseInt(util.getValue(lines, 'TotalTracks', '=')),\n                    tracksPerCylinder: parseInt(util.getValue(lines, 'TracksPerCylinder', '=')),\n                    sectorsPerTrack: parseInt(util.getValue(lines, 'SectorsPerTrack', '=')),\n                    firmwareRevision: util.getValue(lines, 'FirmwareRevision', '=').trim(),\n                    serialNum: util.getValue(lines, 'SerialNumber', '=').trim(),\n                    interfaceType: util.getValue(lines, 'InterfaceType', '=').trim(),\n                    smartStatus: status === 'ok' ? 'Ok' : status === 'degraded' ? 'Degraded' : status === 'pred fail' ? 'Predicted Failure' : 'Unknown'\n                  });\n                }\n              });\n              util.powerShell('Get-PhysicalDisk | Format-List').then(function (data) {\n                var devices = data.split(/\\n\\s*\\n/);\n                devices.forEach(function (device) {\n                  var lines = device.split('\\r\\n');\n                  var serialNum = util.getValue(lines, 'SerialNumber', ':').trim();\n                  var name = util.getValue(lines, 'FriendlyName', ':').trim();\n                  var size = util.getValue(lines, 'Size', ':').trim();\n                  var interfaceType = util.getValue(lines, 'BusType', ':').trim();\n                  var mediaType = util.getValue(lines, 'MediaType', ':').trim();\n\n                  if (mediaType === '3' || mediaType === 'HDD') {\n                    mediaType = 'HD';\n                  }\n\n                  if (mediaType === '4') {\n                    mediaType = 'SSD';\n                  }\n\n                  if (mediaType === '5') {\n                    mediaType = 'SCM';\n                  }\n\n                  if (size) {\n                    var i = util.findObjectByKey(result, 'serialNum', serialNum);\n\n                    if (i === -1) {\n                      i = util.findObjectByKey(result, 'name', name);\n                    }\n\n                    if (i != -1) {\n                      result[i].type = mediaType;\n                      result[i].interfaceType = interfaceType;\n                    }\n                  }\n                });\n\n                if (callback) {\n                  callback(result);\n                }\n\n                resolve(result);\n              }).catch(function () {\n                if (callback) {\n                  callback(result);\n                }\n\n                resolve(result);\n              });\n            } else {\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.diskLayout = diskLayout;","map":null,"metadata":{},"sourceType":"script"}