{"ast":null,"code":"'use strict'; // ==================================================================================\n// cpu.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2018\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 4. CPU\n// ----------------------------------------------------------------------------------\n\nvar os = require('os');\n\nvar exec = require('child_process').exec;\n\nvar execSync = require('child_process').execSync;\n\nvar fs = require('fs');\n\nvar util = require('./util');\n\nvar _platform = process.platform;\n\nvar _linux = _platform === 'linux';\n\nvar _darwin = _platform === 'darwin';\n\nvar _windows = _platform === 'win32';\n\nvar _freebsd = _platform === 'freebsd';\n\nvar _openbsd = _platform === 'openbsd';\n\nvar _sunos = _platform === 'sunos';\n\nvar _cpu_speed = '0.00';\nvar _current_cpu = {\n  user: 0,\n  nice: 0,\n  system: 0,\n  idle: 0,\n  irq: 0,\n  load: 0,\n  tick: 0,\n  ms: 0,\n  currentload: 0,\n  currentload_user: 0,\n  currentload_system: 0,\n  currentload_nice: 0,\n  currentload_idle: 0,\n  currentload_irq: 0,\n  raw_currentload: 0,\n  raw_currentload_user: 0,\n  raw_currentload_system: 0,\n  raw_currentload_nice: 0,\n  raw_currentload_idle: 0,\n  raw_currentload_irq: 0\n};\nvar _cpus = [];\nvar _corecount = 0;\nvar AMDBaseFrequencies = {\n  'FX|4100': '3.6',\n  'FX|4120': '3.9',\n  'FX|4130': '3.8',\n  'FX|4150': '3.8',\n  'FX|4170': '4.2',\n  'FX|6100': '3.3',\n  'FX|6120': '3.6',\n  'FX|6130': '3.6',\n  'FX|6200': '3.8',\n  'FX|8100': '2.8',\n  'FX|8120': '3.1',\n  'FX|8140': '3.2',\n  'FX|8150': '3.6',\n  'FX|8170': '3.9',\n  'FX|4300': '3.8',\n  'FX|4320': '4.0',\n  'FX|4350': '4.2',\n  'FX|6300': '3.5',\n  'FX|6350': '3.9',\n  'FX|8300': '3.3',\n  'FX|8310': '3.4',\n  'FX|8320': '3.5',\n  'FX|8350': '4.0',\n  'FX|8370': '4.0',\n  'FX|9370': '4.4',\n  'FX|9590': '4.7',\n  'FX|8320E': '3.2',\n  'FX|8370E': '3.3',\n  '1950X': '3.4',\n  '1920X': '3.5',\n  '1920': '3.2',\n  '1900X': '3.8',\n  '1800X': '3.6',\n  '1700X': '3.4',\n  'Pro 1700X': '3.5',\n  '1700': '3.0',\n  'Pro 1700': '3.0',\n  '1600X': '3.6',\n  '1600': '3.2',\n  'Pro 1600': '3.2',\n  '1500X': '3.5',\n  'Pro 1500': '3.5',\n  '1400': '3.2',\n  '1300X': '3.5',\n  'Pro 1300': '3.5',\n  '1200': '3.1',\n  'Pro 1200': '3.1',\n  '2200U': '2.5',\n  '2300U': '2.0',\n  'Pro 2300U': '2.0',\n  '2500U': '2.0',\n  'Pro 2500U': '2.2',\n  '2700U': '2.0',\n  'Pro 2700U': '2.2',\n  '2600H': '3.2',\n  '2800H': '3.3',\n  '7601': '2.2',\n  '7551': '2.0',\n  '7501': '2.0',\n  '74501': '2.3',\n  '7401': '2.0',\n  '7351': '2.4',\n  '7301': '2.2',\n  '7281': '2.1',\n  '7251': '2.1',\n  '7551P': '2.0',\n  '7401P': '2.0',\n  '7351P': '2.4'\n};\nvar socketTypes = {\n  1: 'Other',\n  2: 'Unknown',\n  3: 'Daughter Board',\n  4: 'ZIF Socket',\n  5: 'Replacement/Piggy Back',\n  6: 'None',\n  7: 'LIF Socket',\n  8: 'Slot 1',\n  9: 'Slot 2',\n  10: '370 Pin Socket',\n  11: 'Slot A',\n  12: 'Slot M',\n  13: '423',\n  14: 'A (Socket 462)',\n  15: '478',\n  16: '754',\n  17: '940',\n  18: '939',\n  19: 'mPGA604',\n  20: 'LGA771',\n  21: 'LGA775',\n  22: 'S1',\n  23: 'AM2',\n  24: 'F (1207)',\n  25: 'LGA1366',\n  26: 'G34',\n  27: 'AM3',\n  28: 'C32',\n  29: 'LGA1156',\n  30: 'LGA1567',\n  31: 'PGA988A',\n  32: 'BGA1288',\n  33: 'rPGA988B',\n  34: 'BGA1023',\n  35: 'BGA1224',\n  36: 'LGA1155',\n  37: 'LGA1356',\n  38: 'LGA2011',\n  39: 'FS1',\n  40: 'FS2',\n  41: 'FM1',\n  42: 'FM2',\n  43: 'LGA2011-3',\n  44: 'LGA1356-3',\n  45: 'LGA1150',\n  46: 'BGA1168',\n  47: 'BGA1234',\n  48: 'BGA1364',\n  49: 'AM4',\n  50: 'LGA1151',\n  51: 'BGA1356',\n  52: 'BGA1440',\n  53: 'BGA1515',\n  54: 'LGA3647-1',\n  55: 'SP3',\n  56: 'SP3r2',\n  57: 'LGA2066',\n  58: 'BGA1392',\n  59: 'BGA1510',\n  60: 'BGA1528'\n};\n\nfunction cpuBrandManufacturer(res) {\n  res.brand = res.brand.replace(/\\(R\\)+/g, '®').replace(/\\s+/g, ' ').trim();\n  res.brand = res.brand.replace(/\\(TM\\)+/g, '™').replace(/\\s+/g, ' ').trim();\n  res.brand = res.brand.replace(/\\(C\\)+/g, '©').replace(/\\s+/g, ' ').trim();\n  res.brand = res.brand.replace(/CPU+/g, '').replace(/\\s+/g, ' ').trim();\n  res.manufacturer = res.brand.split(' ')[0];\n  var parts = res.brand.split(' ');\n  parts.shift();\n  res.brand = parts.join(' ');\n  return res;\n}\n\nfunction getAMDSpeed(brand) {\n  var result = '0.00';\n\n  for (var key in AMDBaseFrequencies) {\n    if (AMDBaseFrequencies.hasOwnProperty(key)) {\n      (function () {\n        var parts = key.split('|');\n        var found = 0;\n        parts.forEach(function (item) {\n          if (brand.indexOf(item) > -1) {\n            found++;\n          }\n        });\n\n        if (found === parts.length) {\n          result = AMDBaseFrequencies[key];\n        }\n      })();\n    }\n  }\n\n  return result;\n} // --------------------------\n// CPU - brand, speed\n\n\nfunction getCpu() {\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      var UNKNOWN = 'unknown';\n      var result = {\n        manufacturer: UNKNOWN,\n        brand: UNKNOWN,\n        vendor: '',\n        family: '',\n        model: '',\n        stepping: '',\n        revision: '',\n        voltage: '',\n        speed: '0.00',\n        speedmin: '',\n        speedmax: '',\n        cores: util.cores(),\n        physicalCores: util.cores(),\n        processors: 1,\n        socket: '',\n        cache: {}\n      };\n\n      if (_darwin) {\n        exec('sysctl machdep.cpu hw.cpufrequency_max hw.cpufrequency_min hw.packages hw.physicalcpu_max hw.ncpu', function (error, stdout) {\n          // if (!error) {\n          var lines = stdout.toString().split('\\n');\n          var modelline = util.getValue(lines, 'machdep.cpu.brand_string');\n          result.brand = modelline.split('@')[0].trim();\n          result.speed = modelline.split('@')[1].trim();\n          result.speed = parseFloat(result.speed.replace(/GHz+/g, '')).toFixed(2);\n          _cpu_speed = result.speed;\n          result = cpuBrandManufacturer(result);\n          result.speedmin = (util.getValue(lines, 'hw.cpufrequency_min') / 1000000000.0).toFixed(2);\n          result.speedmax = (util.getValue(lines, 'hw.cpufrequency_max') / 1000000000.0).toFixed(2);\n          result.vendor = util.getValue(lines, 'machdep.cpu.vendor');\n          result.family = util.getValue(lines, 'machdep.cpu.family');\n          result.model = util.getValue(lines, 'machdep.cpu.model');\n          result.stepping = util.getValue(lines, 'machdep.cpu.stepping');\n          var countProcessors = util.getValue(lines, 'hw.packages');\n          var countCores = util.getValue(lines, 'hw.physicalcpu_max');\n          var countThreads = util.getValue(lines, 'hw.ncpu');\n\n          if (countProcessors) {\n            result.processors = parseInt(countProcessors) || 1;\n          }\n\n          if (countCores && countThreads) {\n            result.cores = parseInt(countThreads) || util.cores();\n            result.physicalCores = parseInt(countCores) || util.cores();\n          } // }\n\n\n          cpuCache().then(function (res) {\n            result.cache = res;\n            resolve(result);\n          });\n        });\n      }\n\n      if (_linux) {\n        var modelline = '';\n        var lines = [];\n        if (os.cpus()[0] && os.cpus()[0].model) modelline = os.cpus()[0].model;\n        exec('export LC_ALL=C; lscpu; unset LC_ALL', function (error, stdout) {\n          if (!error) {\n            lines = stdout.toString().split('\\n');\n          }\n\n          modelline = util.getValue(lines, 'model name') || modelline;\n          result.brand = modelline.split('@')[0].trim();\n          result.speed = modelline.split('@')[1] ? parseFloat(modelline.split('@')[1].trim()).toFixed(2) : '0.00';\n\n          if (result.speed === '0.00' && result.brand.indexOf('AMD') > -1) {\n            result.speed = getAMDSpeed(result.brand);\n          }\n\n          if (result.speed === '0.00') {\n            var current = getCpuCurrentSpeedSync();\n            if (current !== '0.00') result.speed = current.avg.toFixed(2);\n          }\n\n          _cpu_speed = result.speed;\n          result.speedmin = Math.round(parseFloat(util.getValue(lines, 'cpu min mhz').replace(/,/g, '.')) / 10.0) / 100;\n          result.speedmin = result.speedmin ? parseFloat(result.speedmin).toFixed(2) : '';\n          result.speedmax = Math.round(parseFloat(util.getValue(lines, 'cpu max mhz').replace(/,/g, '.')) / 10.0) / 100;\n          result.speedmax = result.speedmax ? parseFloat(result.speedmax).toFixed(2) : '';\n          result = cpuBrandManufacturer(result);\n          result.vendor = util.getValue(lines, 'vendor id'); // if (!result.vendor) { result.vendor = util.getValue(lines, 'anbieterkennung'); }\n\n          result.family = util.getValue(lines, 'cpu family'); // if (!result.family) { result.family = util.getValue(lines, 'prozessorfamilie'); }\n\n          result.model = util.getValue(lines, 'model:'); // if (!result.model) { result.model = util.getValue(lines, 'modell:'); }\n\n          result.stepping = util.getValue(lines, 'stepping');\n          result.revision = util.getValue(lines, 'cpu revision');\n          result.cache.l1d = util.getValue(lines, 'l1d cache');\n\n          if (result.cache.l1d) {\n            result.cache.l1d = parseInt(result.cache.l1d) * (result.cache.l1d.indexOf('K') !== -1 ? 1024 : 1);\n          }\n\n          result.cache.l1i = util.getValue(lines, 'l1i cache');\n\n          if (result.cache.l1i) {\n            result.cache.l1i = parseInt(result.cache.l1i) * (result.cache.l1i.indexOf('K') !== -1 ? 1024 : 1);\n          }\n\n          result.cache.l2 = util.getValue(lines, 'l2 cache');\n\n          if (result.cache.l2) {\n            result.cache.l2 = parseInt(result.cache.l2) * (result.cache.l2.indexOf('K') !== -1 ? 1024 : 1);\n          }\n\n          result.cache.l3 = util.getValue(lines, 'l3 cache');\n\n          if (result.cache.l3) {\n            result.cache.l3 = parseInt(result.cache.l3) * (result.cache.l3.indexOf('K') !== -1 ? 1024 : 1);\n          } // # processurs & # threads/core - method 1\n\n\n          var threadsPerCoreInt = 0;\n\n          try {\n            lines = [];\n            lines = execSync('cat /proc/cpuinfo | grep -E \"physical id|core id\"').toString().split('\\n');\n\n            if (lines && lines.length) {\n              result.processors = util.countUniqueLines(lines, 'physical id') || 1;\n              result.physicalCores = util.countUniqueLines(lines, 'core id') / result.processors;\n\n              if (result.physicalCores) {\n                threadsPerCoreInt = result.cores / result.physicalCores;\n              }\n            }\n          } catch (e) {\n            util.noop();\n          } // # threads/core - method 2\n\n\n          if (threadsPerCoreInt === 0) {\n            var threadsPerCore = util.getValue(lines, 'thread(s) per core');\n\n            if (threadsPerCore) {\n              threadsPerCoreInt = parseInt(threadsPerCore, 10);\n\n              if (!isNaN(threadsPerCoreInt)) {\n                result.physicalCores = result.cores / threadsPerCoreInt;\n              }\n            }\n          } // socket type\n\n\n          try {\n            lines = [];\n            lines = execSync('dmidecode –t 4 | grep \"Upgrade: Socket\"').toString().split('\\n');\n\n            if (lines && lines.length) {\n              result.socket = util.getValue(lines, 'Upgrade').replace('Socket', '').trim();\n            }\n          } catch (e) {\n            util.noop();\n          }\n\n          resolve(result);\n        });\n      }\n\n      if (_freebsd || _openbsd) {\n        var _modelline = '';\n        var _lines = [];\n        if (os.cpus()[0] && os.cpus()[0].model) _modelline = os.cpus()[0].model;\n        exec('export LC_ALL=C; dmidecode -t 4; dmidecode -t 7 ; unset LC_ALL', function (error, stdout) {\n          var cache = [];\n\n          if (!error) {\n            var data = stdout.toString().split('# dmidecode');\n            var processor = data.length > 0 ? data[1] : '';\n            cache = data.length > 1 ? data[2].split('Cache Information') : [];\n            _lines = processor.split('\\n');\n          }\n\n          result.brand = _modelline.split('@')[0].trim();\n          result.speed = _modelline.split('@')[1] ? parseFloat(_modelline.split('@')[1].trim()).toFixed(2) : '0.00';\n\n          if (result.speed === '0.00' && result.brand.indexOf('AMD') > -1) {\n            result.speed = getAMDSpeed(result.brand);\n          }\n\n          if (result.speed === '0.00') {\n            var current = getCpuCurrentSpeedSync();\n            if (current !== '0.00') result.speed = current.avg.toFixed(2);\n          }\n\n          _cpu_speed = result.speed;\n          result.speedmin = '';\n          result.speedmax = Math.round(parseFloat(util.getValue(_lines, 'max speed').replace(/Mhz/g, '')) / 10.0) / 100;\n          result.speedmax = result.speedmax ? parseFloat(result.speedmax).toFixed(2) : '';\n          result = cpuBrandManufacturer(result);\n          result.vendor = util.getValue(_lines, 'manufacturer');\n          var sig = util.getValue(_lines, 'signature');\n          sig = sig.split(',');\n\n          for (var i = 0; i < sig.length; i++) {\n            sig[i] = sig[i].trim();\n          }\n\n          result.family = util.getValue(sig, 'Family', ' ', true);\n          result.model = util.getValue(sig, 'Model', ' ', true);\n          result.stepping = util.getValue(sig, 'Stepping', ' ', true);\n          result.revision = '';\n          var voltage = parseFloat(util.getValue(_lines, 'voltage'));\n          result.voltage = isNaN(voltage) ? '' : voltage.toFixed(2);\n\n          for (var _i = 0; _i < cache.length; _i++) {\n            _lines = cache[_i].split('\\n');\n            var cacheType = util.getValue(_lines, 'Socket Designation').toLowerCase().replace(' ', '-').split('-');\n            cacheType = cacheType.length ? cacheType[0] : '';\n            var sizeParts = util.getValue(_lines, 'Installed Size').split(' ');\n            var size = parseInt(sizeParts[0], 10);\n            var unit = sizeParts.length > 1 ? sizeParts[1] : 'kb';\n            size = size * (unit === 'kb' ? 1024 : unit === 'mb' ? 1024 * 1024 : unit === 'gb' ? 1024 * 1024 * 1024 : 1);\n\n            if (cacheType) {\n              if (cacheType === 'l1') {\n                result.cache[cacheType + 'd'] = size / 2;\n                result.cache[cacheType + 'i'] = size / 2;\n              } else {\n                result.cache[cacheType] = size;\n              }\n            }\n          } // socket type\n\n\n          result.socket = util.getValue(_lines, 'Upgrade').replace('Socket', '').trim(); // # threads / # cores\n\n          var threadCount = util.getValue(_lines, 'thread count').trim();\n          var coreCount = util.getValue(_lines, 'core count').trim();\n\n          if (coreCount && threadCount) {\n            result.cores = threadCount;\n            result.physicalCores = coreCount;\n          }\n\n          resolve(result);\n        });\n      }\n\n      if (_sunos) {\n        resolve(result);\n      }\n\n      if (_windows) {\n        try {\n          exec(util.getWmic() + ' cpu get /value', util.execOptsWin, function (error, stdout) {\n            if (!error) {\n              var _lines2 = stdout.split('\\r\\n');\n\n              var name = util.getValue(_lines2, 'name', '=') || '';\n\n              if (name.indexOf('@') >= 0) {\n                result.brand = name.split('@')[0].trim();\n                result.speed = name.split('@')[1].trim();\n                result.speed = parseFloat(result.speed.replace(/GHz+/g, '').trim()).toFixed(2);\n                _cpu_speed = result.speed;\n              } else {\n                result.brand = name.trim();\n                result.speed = 0;\n              }\n\n              result = cpuBrandManufacturer(result);\n              result.revision = util.getValue(_lines2, 'revision', '=');\n              result.cache.l1d = 0;\n              result.cache.l1i = 0;\n              result.cache.l2 = util.getValue(_lines2, 'l2cachesize', '=');\n              result.cache.l3 = util.getValue(_lines2, 'l3cachesize', '=');\n\n              if (result.cache.l2) {\n                result.cache.l2 = parseInt(result.cache.l2, 10) * 1024;\n              }\n\n              if (result.cache.l3) {\n                result.cache.l3 = parseInt(result.cache.l3, 10) * 1024;\n              }\n\n              result.vendor = util.getValue(_lines2, 'manufacturer', '=');\n              result.speedmax = Math.round(parseFloat(util.getValue(_lines2, 'maxclockspeed', '=').replace(/,/g, '.')) / 10.0) / 100;\n              result.speedmax = result.speedmax ? parseFloat(result.speedmax).toFixed(2) : '';\n\n              if (!result.speed && result.brand.indexOf('AMD') > -1) {\n                result.speed = getAMDSpeed(result.brand);\n              }\n\n              if (!result.speed) {\n                result.speed = result.speedmax;\n              }\n\n              var description = util.getValue(_lines2, 'description', '=').split(' ');\n\n              for (var i = 0; i < description.length; i++) {\n                if (description[i].toLowerCase().startsWith('family') && i + 1 < description.length && description[i + 1]) {\n                  result.family = description[i + 1];\n                }\n\n                if (description[i].toLowerCase().startsWith('model') && i + 1 < description.length && description[i + 1]) {\n                  result.model = description[i + 1];\n                }\n\n                if (description[i].toLowerCase().startsWith('stepping') && i + 1 < description.length && description[i + 1]) {\n                  result.stepping = description[i + 1];\n                }\n              } // socket type\n\n\n              var socketId = util.getValue(_lines2, 'UpgradeMethod', '=');\n\n              if (socketTypes[socketId]) {\n                result.socket = socketTypes[socketId];\n              } // # threads / # cores\n\n\n              var countProcessors = util.countUniqueLines(_lines2, 'Caption');\n              var countThreads = util.getValue(_lines2, 'NumberOfLogicalProcessors', '=');\n              var countCores = util.getValue(_lines2, 'NumberOfCores', '=');\n\n              if (countProcessors) {\n                result.processors = parseInt(countProcessors) || 1;\n              }\n\n              if (countCores && countThreads) {\n                result.cores = parseInt(countThreads) || util.cores();\n                result.physicalCores = parseInt(countCores) || util.cores();\n              }\n            }\n\n            exec(util.getWmic() + ' path Win32_CacheMemory get CacheType,InstalledSize,Purpose', function (error, stdout) {\n              if (!error) {\n                var _lines3 = stdout.split('\\r\\n').filter(function (line) {\n                  return line.trim() !== '';\n                }).filter(function (line, idx) {\n                  return idx > 0;\n                });\n\n                _lines3.forEach(function (line) {\n                  if (line !== '') {\n                    line = line.trim().split(/\\s\\s+/); // L1 Instructions\n\n                    if (line[2] === 'L1 Cache' && line[0] === '3') {\n                      result.cache.l1i = parseInt(line[1], 10);\n                    } // L1 Data\n\n\n                    if (line[2] === 'L1 Cache' && line[0] === '4') {\n                      result.cache.l1d = parseInt(line[1], 10);\n                    }\n                  }\n                });\n              }\n\n              resolve(result);\n            });\n          });\n        } catch (e) {\n          resolve(result);\n        }\n      }\n    });\n  });\n} // --------------------------\n// CPU - Processor Data\n\n\nfunction cpu(callback) {\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      getCpu().then(function (result) {\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.cpu = cpu; // --------------------------\n// CPU - current speed - in GHz\n\nfunction getCpuCurrentSpeedSync() {\n  var cpus = os.cpus();\n  var minFreq = 999999999;\n  var maxFreq = 0;\n  var avgFreq = 0;\n  var cores = [];\n\n  if (cpus.length) {\n    for (var i in cpus) {\n      if (cpus.hasOwnProperty(i)) {\n        avgFreq = avgFreq + cpus[i].speed;\n        if (cpus[i].speed > maxFreq) maxFreq = cpus[i].speed;\n        if (cpus[i].speed < minFreq) minFreq = cpus[i].speed;\n      }\n\n      cores.push(parseFloat(((cpus[i].speed + 1) / 1000).toFixed(2)));\n    }\n\n    avgFreq = avgFreq / cpus.length;\n    return {\n      min: parseFloat(((minFreq + 1) / 1000).toFixed(2)),\n      max: parseFloat(((maxFreq + 1) / 1000).toFixed(2)),\n      avg: parseFloat(((avgFreq + 1) / 1000).toFixed(2)),\n      cores: cores\n    };\n  } else {\n    return {\n      min: 0,\n      max: 0,\n      avg: 0,\n      cores: cores\n    };\n  }\n}\n\nfunction cpuCurrentspeed(callback) {\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      var result = getCpuCurrentSpeedSync();\n      if (result === 0 && _cpu_speed !== '0.00') result = parseFloat(_cpu_speed);\n\n      if (callback) {\n        callback(result);\n      }\n\n      resolve(result);\n    });\n  });\n}\n\nexports.cpuCurrentspeed = cpuCurrentspeed; // --------------------------\n// CPU - temperature\n// if sensors are installed\n\nfunction cpuTemperature(callback) {\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      var result = {\n        main: -1.0,\n        cores: [],\n        max: -1.0\n      };\n\n      if (_linux) {\n        exec('sensors', function (error, stdout) {\n          if (!error) {\n            var lines = stdout.toString().split('\\n');\n            lines.forEach(function (line) {\n              var regex = /[+-]([^°]*)/g;\n              var temps = line.match(regex);\n              var firstPart = line.split(':')[0].toUpperCase();\n\n              if (firstPart.indexOf('PHYSICAL') !== -1 || firstPart.indexOf('PACKAGE') !== -1) {\n                result.main = parseFloat(temps);\n              }\n\n              if (firstPart.indexOf('CORE ') !== -1) {\n                result.cores.push(parseFloat(temps));\n              }\n            });\n\n            if (result.cores.length > 0) {\n              var maxtmp = Math.max.apply(Math, result.cores);\n              result.max = maxtmp > result.main ? maxtmp : result.main;\n            }\n\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          } else {\n            fs.stat('/sys/class/thermal/thermal_zone0/temp', function (err) {\n              if (err === null) {\n                exec('cat /sys/class/thermal/thermal_zone0/temp', function (error, stdout) {\n                  if (!error) {\n                    var _lines4 = stdout.toString().split('\\n');\n\n                    if (_lines4.length > 0) {\n                      result.main = parseFloat(_lines4[0]) / 1000.0;\n                      result.max = result.main;\n                    }\n                  }\n\n                  if (callback) {\n                    callback(result);\n                  }\n\n                  resolve(result);\n                });\n              } else {\n                exec('/opt/vc/bin/vcgencmd measure_temp', function (error, stdout) {\n                  if (!error) {\n                    var _lines5 = stdout.toString().split('\\n');\n\n                    if (_lines5.length > 0 && _lines5[0].indexOf('=')) {\n                      result.main = parseFloat(_lines5[0].split('=')[1]);\n                      result.max = result.main;\n                    }\n                  }\n\n                  if (callback) {\n                    callback(result);\n                  }\n\n                  resolve(result);\n                });\n              }\n            });\n          }\n        });\n      }\n\n      if (_freebsd || _openbsd) {\n        exec('sysctl dev.cpu | grep temp', function (error, stdout) {\n          if (!error) {\n            var lines = stdout.toString().split('\\n');\n            var sum = 0;\n            lines.forEach(function (line) {\n              var parts = line.split(':');\n\n              if (parts.length > 0) {\n                var temp = parseFloat(parts[1].replace(',', '.'));\n                if (temp > result.max) result.max = temp;\n                sum = sum + temp;\n                result.cores.push(temp);\n              }\n            });\n\n            if (result.cores.length) {\n              result.main = Math.round(sum / result.cores.length * 100) / 100;\n            }\n          }\n\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        });\n      }\n\n      if (_darwin) {\n        var osxTemp = null;\n\n        try {\n          osxTemp = require('osx-temperature-sensor');\n        } catch (er) {\n          osxTemp = null;\n        }\n\n        if (osxTemp) {\n          result = osxTemp.cpuTemperature();\n        }\n\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n\n      if (_sunos) {\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n\n      if (_windows) {\n        try {\n          exec(util.getWmic() + ' /namespace:\\\\\\\\root\\\\wmi PATH MSAcpi_ThermalZoneTemperature get CurrentTemperature', util.execOptsWin, function (error, stdout) {\n            if (!error) {\n              var sum = 0;\n              var lines = stdout.split('\\r\\n').filter(function (line) {\n                return line.trim() !== '';\n              }).filter(function (line, idx) {\n                return idx > 0;\n              });\n              lines.forEach(function (line) {\n                var value = (parseInt(line, 10) - 2732) / 10;\n                sum = sum + value;\n                if (value > result.max) result.max = value;\n                result.cores.push(value);\n              });\n\n              if (result.cores.length) {\n                result.main = sum / result.cores.length;\n              }\n            }\n\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.cpuTemperature = cpuTemperature; // --------------------------\n// CPU Flags\n\nfunction cpuFlags(callback) {\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      var result = '';\n\n      if (_windows) {\n        try {\n          exec('reg query \"HKEY_LOCAL_MACHINE\\\\HARDWARE\\\\DESCRIPTION\\\\System\\\\CentralProcessor\\\\0\" /v FeatureSet', util.execOptsWin, function (error, stdout) {\n            if (!error) {\n              var flag_hex = stdout.split('0x').pop().trim();\n              var flag_bin_unpadded = parseInt(flag_hex, 16).toString(2);\n              var flag_bin = '0'.repeat(32 - flag_bin_unpadded.length) + flag_bin_unpadded; // empty flags are the reserved fields in the CPUID feature bit list\n              // as found on wikipedia:\n              // https://en.wikipedia.org/wiki/CPUID\n\n              var all_flags = ['fpu', 'vme', 'de', 'pse', 'tsc', 'msr', 'pae', 'mce', 'cx8', 'apic', '', 'sep', 'mtrr', 'pge', 'mca', 'cmov', 'pat', 'pse-36', 'psn', 'clfsh', '', 'ds', 'acpi', 'mmx', 'fxsr', 'sse', 'sse2', 'ss', 'htt', 'tm', 'ia64', 'pbe'];\n\n              for (var f = 0; f < all_flags.length; f++) {\n                if (flag_bin[f] === '1' && all_flags[f] !== '') {\n                  result += ' ' + all_flags[f];\n                }\n              }\n\n              result = result.trim();\n            }\n\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        }\n      }\n\n      if (_linux) {\n        exec('export LC_ALL=C; lscpu; unset LC_ALL', function (error, stdout) {\n          if (!error) {\n            var lines = stdout.toString().split('\\n');\n            lines.forEach(function (line) {\n              if (line.split(':')[0].toUpperCase().indexOf('FLAGS') !== -1) {\n                result = line.split(':')[1].trim().toLowerCase();\n              }\n            });\n          }\n\n          if (!result) {\n            exec('cat /proc/cpuinfo', function (error, stdout) {\n              if (!error) {\n                var _lines6 = stdout.toString().split('\\n');\n\n                result = util.getValue(_lines6, 'features', ':', true).toLowerCase();\n              }\n\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            });\n          } else {\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          }\n        });\n      }\n\n      if (_freebsd || _openbsd) {\n        exec('export LC_ALL=C; dmidecode -t 4; unset LC_ALL', function (error, stdout) {\n          var flags = [];\n\n          if (!error) {\n            var parts = stdout.toString().split('\\tFlags:');\n            var lines = parts.length > 1 ? parts[1].split('\\tVersion:')[0].split['\\n'] : [];\n            lines.forEach(function (line) {\n              var flag = (line.indexOf('(') ? line.split('(')[0].toLowerCase() : '').trim().replace(/\\t/g, '');\n\n              if (flag) {\n                flags.push(flag);\n              }\n            });\n          }\n\n          result = flags.join(' ').trim();\n\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        });\n      }\n\n      if (_darwin) {\n        exec('sysctl machdep.cpu.features', function (error, stdout) {\n          if (!error) {\n            var lines = stdout.toString().split('\\n');\n\n            if (lines.length > 0 && lines[0].indexOf('machdep.cpu.features:') !== -1) {\n              result = lines[0].split(':')[1].trim().toLowerCase();\n            }\n          }\n\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        });\n      }\n\n      if (_sunos) {\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.cpuFlags = cpuFlags; // --------------------------\n// CPU Flags\n\nfunction cpuCache(callback) {\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      var result = {\n        l1d: -1,\n        l1i: -1,\n        l2: -1,\n        l3: -1\n      };\n\n      if (_linux) {\n        exec('export LC_ALL=C; lscpu; unset LC_ALL', function (error, stdout) {\n          if (!error) {\n            var lines = stdout.toString().split('\\n');\n            lines.forEach(function (line) {\n              var parts = line.split(':');\n\n              if (parts[0].toUpperCase().indexOf('L1D CACHE') !== -1) {\n                result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n\n              if (parts[0].toUpperCase().indexOf('L1I CACHE') !== -1) {\n                result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n\n              if (parts[0].toUpperCase().indexOf('L2 CACHE') !== -1) {\n                result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n\n              if (parts[0].toUpperCase().indexOf('L3 CACHE') !== -1) {\n                result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n            });\n          }\n\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        });\n      }\n\n      if (_freebsd || _openbsd) {\n        exec('export LC_ALL=C; dmidecode -t 7 ; unset LC_ALL', function (error, stdout) {\n          var cache = [];\n\n          if (!error) {\n            var data = stdout.toString();\n            cache = data.split('Cache Information');\n            cache.shift();\n          }\n\n          for (var i = 0; i < cache.length; i++) {\n            var lines = cache[i].split('\\n');\n            var cacheType = util.getValue(lines, 'Socket Designation').toLowerCase().replace(' ', '-').split('-');\n            cacheType = cacheType.length ? cacheType[0] : '';\n            var sizeParts = util.getValue(lines, 'Installed Size').split(' ');\n            var size = parseInt(sizeParts[0], 10);\n            var unit = sizeParts.length > 1 ? sizeParts[1] : 'kb';\n            size = size * (unit === 'kb' ? 1024 : unit === 'mb' ? 1024 * 1024 : unit === 'gb' ? 1024 * 1024 * 1024 : 1);\n\n            if (cacheType) {\n              if (cacheType === 'l1') {\n                result.cache[cacheType + 'd'] = size / 2;\n                result.cache[cacheType + 'i'] = size / 2;\n              } else {\n                result.cache[cacheType] = size;\n              }\n            }\n          }\n\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        });\n      }\n\n      if (_darwin) {\n        exec('sysctl hw.l1icachesize hw.l1dcachesize hw.l2cachesize hw.l3cachesize', function (error, stdout) {\n          if (!error) {\n            var lines = stdout.toString().split('\\n');\n            lines.forEach(function (line) {\n              var parts = line.split(':');\n\n              if (parts[0].toLowerCase().indexOf('hw.l1icachesize') !== -1) {\n                result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n\n              if (parts[0].toLowerCase().indexOf('hw.l1dcachesize') !== -1) {\n                result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n\n              if (parts[0].toLowerCase().indexOf('hw.l2cachesize') !== -1) {\n                result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n\n              if (parts[0].toLowerCase().indexOf('hw.l3cachesize') !== -1) {\n                result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n            });\n          }\n\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        });\n      }\n\n      if (_sunos) {\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n\n      if (_windows) {\n        try {\n          exec(util.getWmic() + ' cpu get l2cachesize, l3cachesize /value', util.execOptsWin, function (error, stdout) {\n            if (!error) {\n              var lines = stdout.split('\\r\\n');\n              result.l1d = 0;\n              result.l1i = 0;\n              result.l2 = util.getValue(lines, 'l2cachesize', '=');\n              result.l3 = util.getValue(lines, 'l3cachesize', '=');\n\n              if (result.l2) {\n                result.l2 = parseInt(result.l2, 10) * 1024;\n              }\n\n              if (result.l3) {\n                result.l3 = parseInt(result.l3, 10) * 1024;\n              }\n            }\n\n            exec(util.getWmic() + ' path Win32_CacheMemory get CacheType,InstalledSize,Purpose', function (error, stdout) {\n              if (!error) {\n                var _lines7 = stdout.split('\\r\\n').filter(function (line) {\n                  return line.trim() !== '';\n                }).filter(function (line, idx) {\n                  return idx > 0;\n                });\n\n                _lines7.forEach(function (line) {\n                  if (line !== '') {\n                    line = line.trim().split(/\\s\\s+/); // L1 Instructions\n\n                    if (line[2] === 'L1 Cache' && line[0] === '3') {\n                      result.l1i = parseInt(line[1], 10);\n                    } // L1 Data\n\n\n                    if (line[2] === 'L1 Cache' && line[0] === '4') {\n                      result.l1d = parseInt(line[1], 10);\n                    }\n                  }\n                });\n              }\n\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            });\n          });\n        } catch (e) {\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.cpuCache = cpuCache; // --------------------------\n// CPU - current load - in %\n\nfunction getLoad() {\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      var loads = os.loadavg().map(function (x) {\n        return x / util.cores();\n      });\n      var avgload = parseFloat(Math.max.apply(Math, loads).toFixed(2));\n      var result = {};\n\n      var now = Date.now() - _current_cpu.ms;\n\n      if (now >= 200) {\n        _current_cpu.ms = Date.now();\n        var cpus = os.cpus();\n        var totalUser = 0;\n        var totalSystem = 0;\n        var totalNice = 0;\n        var totalIrq = 0;\n        var totalIdle = 0;\n        var cores = [];\n        _corecount = cpus.length;\n\n        for (var i = 0; i < _corecount; i++) {\n          var _cpu = cpus[i].times;\n          totalUser += _cpu.user;\n          totalSystem += _cpu.sys;\n          totalNice += _cpu.nice;\n          totalIdle += _cpu.idle;\n          totalIrq += _cpu.irq;\n          var tmp_tick = _cpus && _cpus[i] && _cpus[i].totalTick ? _cpus[i].totalTick : 0;\n          var tmp_load = _cpus && _cpus[i] && _cpus[i].totalLoad ? _cpus[i].totalLoad : 0;\n          var tmp_user = _cpus && _cpus[i] && _cpus[i].user ? _cpus[i].user : 0;\n          var tmp_system = _cpus && _cpus[i] && _cpus[i].sys ? _cpus[i].sys : 0;\n          var tmp_nice = _cpus && _cpus[i] && _cpus[i].nice ? _cpus[i].nice : 0;\n          var tmp_idle = _cpus && _cpus[i] && _cpus[i].idle ? _cpus[i].idle : 0;\n          var tmp_irq = _cpus && _cpus[i] && _cpus[i].irq ? _cpus[i].irq : 0;\n          _cpus[i] = _cpu;\n          _cpus[i].totalTick = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq + _cpus[i].idle;\n          _cpus[i].totalLoad = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq;\n          _cpus[i].currentTick = _cpus[i].totalTick - tmp_tick;\n          _cpus[i].load = _cpus[i].totalLoad - tmp_load;\n          _cpus[i].load_user = _cpus[i].user - tmp_user;\n          _cpus[i].load_system = _cpus[i].sys - tmp_system;\n          _cpus[i].load_nice = _cpus[i].nice - tmp_nice;\n          _cpus[i].load_idle = _cpus[i].idle - tmp_idle;\n          _cpus[i].load_irq = _cpus[i].irq - tmp_irq;\n          cores[i] = {};\n          cores[i].load = _cpus[i].load / _cpus[i].currentTick * 100;\n          cores[i].load_user = _cpus[i].load_user / _cpus[i].currentTick * 100;\n          cores[i].load_system = _cpus[i].load_system / _cpus[i].currentTick * 100;\n          cores[i].load_nice = _cpus[i].load_nice / _cpus[i].currentTick * 100;\n          cores[i].load_idle = _cpus[i].load_idle / _cpus[i].currentTick * 100;\n          cores[i].load_irq = _cpus[i].load_irq / _cpus[i].currentTick * 100;\n          cores[i].raw_load = _cpus[i].load;\n          cores[i].raw_load_user = _cpus[i].load_user;\n          cores[i].raw_load_system = _cpus[i].load_system;\n          cores[i].raw_load_nice = _cpus[i].load_nice;\n          cores[i].raw_load_idle = _cpus[i].load_idle;\n          cores[i].raw_load_irq = _cpus[i].load_irq;\n        }\n\n        var totalTick = totalUser + totalSystem + totalNice + totalIrq + totalIdle;\n        var totalLoad = totalUser + totalSystem + totalNice + totalIrq;\n        var currentTick = totalTick - _current_cpu.tick;\n        result = {\n          avgload: avgload,\n          currentload: (totalLoad - _current_cpu.load) / currentTick * 100,\n          currentload_user: (totalUser - _current_cpu.user) / currentTick * 100,\n          currentload_system: (totalSystem - _current_cpu.system) / currentTick * 100,\n          currentload_nice: (totalNice - _current_cpu.nice) / currentTick * 100,\n          currentload_idle: (totalIdle - _current_cpu.idle) / currentTick * 100,\n          currentload_irq: (totalIrq - _current_cpu.irq) / currentTick * 100,\n          raw_currentload: totalLoad - _current_cpu.load,\n          raw_currentload_user: totalUser - _current_cpu.user,\n          raw_currentload_system: totalSystem - _current_cpu.system,\n          raw_currentload_nice: totalNice - _current_cpu.nice,\n          raw_currentload_idle: totalIdle - _current_cpu.idle,\n          raw_currentload_irq: totalIrq - _current_cpu.irq,\n          cpus: cores\n        };\n        _current_cpu = {\n          user: totalUser,\n          nice: totalNice,\n          system: totalSystem,\n          idle: totalIdle,\n          irq: totalIrq,\n          tick: totalTick,\n          load: totalLoad,\n          ms: _current_cpu.ms,\n          currentload: result.currentload,\n          currentload_user: result.currentload_user,\n          currentload_system: result.currentload_system,\n          currentload_nice: result.currentload_nice,\n          currentload_idle: result.currentload_idle,\n          currentload_irq: result.currentload_irq,\n          raw_currentload: result.raw_currentload,\n          raw_currentload_user: result.raw_currentload_user,\n          raw_currentload_system: result.raw_currentload_system,\n          raw_currentload_nice: result.raw_currentload_nice,\n          raw_currentload_idle: result.raw_currentload_idle,\n          raw_currentload_irq: result.raw_currentload_irq\n        };\n      } else {\n        var _cores = [];\n\n        for (var _i2 = 0; _i2 < _corecount; _i2++) {\n          _cores[_i2] = {};\n          _cores[_i2].load = _cpus[_i2].load / _cpus[_i2].currentTick * 100;\n          _cores[_i2].load_user = _cpus[_i2].load_user / _cpus[_i2].currentTick * 100;\n          _cores[_i2].load_system = _cpus[_i2].load_system / _cpus[_i2].currentTick * 100;\n          _cores[_i2].load_nice = _cpus[_i2].load_nice / _cpus[_i2].currentTick * 100;\n          _cores[_i2].load_idle = _cpus[_i2].load_idle / _cpus[_i2].currentTick * 100;\n          _cores[_i2].load_irq = _cpus[_i2].load_irq / _cpus[_i2].currentTick * 100;\n          _cores[_i2].raw_load = _cpus[_i2].load;\n          _cores[_i2].raw_load_user = _cpus[_i2].load_user;\n          _cores[_i2].raw_load_system = _cpus[_i2].load_system;\n          _cores[_i2].raw_load_nice = _cpus[_i2].load_nice;\n          _cores[_i2].raw_load_idle = _cpus[_i2].load_idle;\n          _cores[_i2].raw_load_irq = _cpus[_i2].load_irq;\n        }\n\n        result = {\n          avgload: avgload,\n          currentload: _current_cpu.currentload,\n          currentload_user: _current_cpu.currentload_user,\n          currentload_system: _current_cpu.currentload_system,\n          currentload_nice: _current_cpu.currentload_nice,\n          currentload_idle: _current_cpu.currentload_idle,\n          currentload_irq: _current_cpu.currentload_irq,\n          raw_currentload: _current_cpu.raw_currentload,\n          raw_currentload_user: _current_cpu.raw_currentload_user,\n          raw_currentload_system: _current_cpu.raw_currentload_system,\n          raw_currentload_nice: _current_cpu.raw_currentload_nice,\n          raw_currentload_idle: _current_cpu.raw_currentload_idle,\n          raw_currentload_irq: _current_cpu.raw_currentload_irq,\n          cpus: _cores\n        };\n      }\n\n      resolve(result);\n    });\n  });\n}\n\nfunction currentLoad(callback) {\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      getLoad().then(function (result) {\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.currentLoad = currentLoad; // --------------------------\n// PS - full load\n// since bootup\n\nfunction getFullLoad() {\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      var cpus = os.cpus();\n      var totalUser = 0;\n      var totalSystem = 0;\n      var totalNice = 0;\n      var totalIrq = 0;\n      var totalIdle = 0;\n\n      for (var i = 0, len = cpus.length; i < len; i++) {\n        var _cpu2 = cpus[i].times;\n        totalUser += _cpu2.user;\n        totalSystem += _cpu2.sys;\n        totalNice += _cpu2.nice;\n        totalIrq += _cpu2.irq;\n        totalIdle += _cpu2.idle;\n      }\n\n      var totalTicks = totalIdle + totalIrq + totalNice + totalSystem + totalUser;\n      var result = (totalTicks - totalIdle) / totalTicks * 100.0;\n      resolve(result);\n    });\n  });\n}\n\nfunction fullLoad(callback) {\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      getFullLoad().then(function (result) {\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.fullLoad = fullLoad;","map":null,"metadata":{},"sourceType":"script"}