{"ast":null,"code":"'use strict'; // ==================================================================================\n// network.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2018\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 9. Network\n// ----------------------------------------------------------------------------------\n\nvar os = require('os');\n\nvar exec = require('child_process').exec;\n\nvar execSync = require('child_process').execSync;\n\nvar fs = require('fs');\n\nvar util = require('./util');\n\nvar _platform = process.platform;\n\nvar _linux = _platform === 'linux';\n\nvar _darwin = _platform === 'darwin';\n\nvar _windows = _platform === 'win32';\n\nvar _freebsd = _platform === 'freebsd';\n\nvar _openbsd = _platform === 'openbsd';\n\nvar _sunos = _platform === 'sunos';\n\nvar _network = {};\n\nvar _default_iface;\n\nvar _mac = {};\nvar pathToIp;\n\nfunction getDefaultNetworkInterface() {\n  var ifaces = os.networkInterfaces();\n  var ifacename = '';\n  var scopeid = 9999; // fallback - \"first\" external interface (sorted by scopeid)\n\n  var _loop = function _loop(dev) {\n    if (ifaces.hasOwnProperty(dev)) {\n      ifaces[dev].forEach(function (details) {\n        if (details && details.internal === false && details.scopeid && details.scopeid < scopeid) {\n          ifacename = dev;\n          scopeid = details.scopeid;\n        }\n      });\n    }\n  };\n\n  for (var dev in ifaces) {\n    _loop(dev);\n  }\n\n  if (_linux || _darwin || _freebsd || _openbsd || _sunos) {\n    var cmd = '';\n    if (_linux) cmd = 'route 2>/dev/null | grep default | awk \\'{print $8}\\'';\n    if (_darwin) cmd = 'route get 0.0.0.0 2>/dev/null | grep interface: | awk \\'{print $2}\\'';\n    if (_freebsd || _openbsd || _sunos) cmd = 'route get 0.0.0.0 | grep interface:';\n    var result = execSync(cmd);\n    ifacename = result.toString().split('\\n')[0];\n\n    if (ifacename.indexOf(':') > -1) {\n      ifacename = ifacename.split(':')[1].trim();\n    }\n  }\n\n  if (ifacename) _default_iface = ifacename;\n  return _default_iface;\n}\n\nexports.getDefaultNetworkInterface = getDefaultNetworkInterface;\n\nfunction getMacAddresses() {\n  var iface = '';\n  var mac = '';\n  var result = {};\n\n  if (_linux || _freebsd || _openbsd) {\n    if (typeof pathToIp === 'undefined') {\n      try {\n        var _lines = execSync('which ip').toString().split('\\n');\n\n        if (_lines.length && _lines[0].indexOf(':') === -1 && _lines[0].indexOf('/') === 0) {\n          pathToIp = _lines[0];\n        } else {\n          pathToIp = '';\n        }\n      } catch (e) {\n        pathToIp = '';\n      }\n    }\n\n    var cmd = 'export LC_ALL=C; ' + (pathToIp ? pathToIp + ' link show up' : '/sbin/ifconfig') + '; unset LC_ALL';\n    var res = execSync(cmd);\n    var lines = res.toString().split('\\n');\n\n    for (var i = 0; i < lines.length; i++) {\n      if (lines[i] && lines[i][0] !== ' ') {\n        if (pathToIp) {\n          var nextline = lines[i + 1].trim().split(' ');\n\n          if (nextline[0] === 'link/ether') {\n            iface = lines[i].split(' ')[1];\n            iface = iface.slice(0, iface.length - 1);\n            mac = nextline[1];\n          }\n        } else {\n          iface = lines[i].split(' ')[0];\n          mac = lines[i].split('HWaddr ')[1];\n        }\n\n        if (iface && mac) {\n          result[iface] = mac.trim();\n          iface = '';\n          mac = '';\n        }\n      }\n    }\n  }\n\n  if (_darwin) {\n    var _cmd = '/sbin/ifconfig';\n\n    var _res = execSync(_cmd);\n\n    var _lines2 = _res.toString().split('\\n');\n\n    for (var _i = 0; _i < _lines2.length; _i++) {\n      if (_lines2[_i] && _lines2[_i][0] !== '\\t' && _lines2[_i].indexOf(':') > 0) {\n        iface = _lines2[_i].split(':')[0];\n      } else if (_lines2[_i].indexOf('\\tether ') === 0) {\n        mac = _lines2[_i].split('\\tether ')[1];\n\n        if (iface && mac) {\n          result[iface] = mac.trim();\n          iface = '';\n          mac = '';\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction networkInterfaceDefault(callback) {\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      var result = getDefaultNetworkInterface();\n\n      if (callback) {\n        callback(result);\n      }\n\n      resolve(result);\n    });\n  });\n}\n\nexports.networkInterfaceDefault = networkInterfaceDefault; // --------------------------\n// NET - interfaces\n\nfunction networkInterfaces(callback) {\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      var ifaces = os.networkInterfaces();\n      var result = [];\n\n      var _loop2 = function _loop2(dev) {\n        var ip4 = '';\n        var ip6 = '';\n        var mac = '';\n\n        if (ifaces.hasOwnProperty(dev)) {\n          ifaces[dev].forEach(function (details) {\n            if (details.family === 'IPv4') {\n              ip4 = details.address;\n            }\n\n            if (details.family === 'IPv6') {\n              if (!ip6 || ip6.match(/^fe80::/i)) {\n                ip6 = details.address;\n              }\n            }\n\n            mac = details.mac;\n\n            if (mac.indexOf('00:00:0') > -1 && (_linux || _darwin)) {\n              if (Object.keys(_mac).length === 0) {\n                _mac = getMacAddresses();\n              }\n\n              mac = _mac[dev] || '';\n            }\n          });\n          var internal = ifaces[dev] && ifaces[dev][0] ? ifaces[dev][0].internal : null;\n          result.push({\n            iface: dev,\n            ip4: ip4,\n            ip6: ip6,\n            mac: mac,\n            internal: internal\n          });\n        }\n      };\n\n      for (var dev in ifaces) {\n        _loop2(dev);\n      }\n\n      if (callback) {\n        callback(result);\n      }\n\n      resolve(result);\n    });\n  });\n}\n\nexports.networkInterfaces = networkInterfaces; // --------------------------\n// NET - Speed\n\nfunction calcNetworkSpeed(iface, rx, tx, operstate) {\n  var result = {\n    iface: iface,\n    operstate: operstate,\n    rx: rx,\n    tx: tx,\n    rx_sec: -1,\n    tx_sec: -1,\n    ms: 0\n  };\n\n  if (_network[iface] && _network[iface].ms) {\n    result.ms = Date.now() - _network[iface].ms;\n    result.rx_sec = rx - _network[iface].rx >= 0 ? (rx - _network[iface].rx) / (result.ms / 1000) : 0;\n    result.tx_sec = tx - _network[iface].tx >= 0 ? (tx - _network[iface].tx) / (result.ms / 1000) : 0;\n    _network[iface].rx = rx;\n    _network[iface].tx = tx;\n    _network[iface].rx_sec = result.rx_sec;\n    _network[iface].tx_sec = result.tx_sec;\n    _network[iface].ms = Date.now();\n    _network[iface].last_ms = result.ms;\n    _network[iface].operstate = operstate;\n  } else {\n    if (!_network[iface]) _network[iface] = {};\n    _network[iface].rx = rx;\n    _network[iface].tx = tx;\n    _network[iface].rx_sec = -1;\n    _network[iface].tx_sec = -1;\n    _network[iface].ms = Date.now();\n    _network[iface].last_ms = 0;\n    _network[iface].operstate = operstate;\n  }\n\n  return result;\n}\n\nfunction networkStats(iface, callback) {\n  function parseLinesWindowsNics(sections) {\n    var nics = [];\n\n    for (var i in sections) {\n      if (sections.hasOwnProperty(i)) {\n        if (sections[i].trim() !== '') {\n          var lines = sections[i].trim().split('\\r\\n');\n          var netEnabled = util.getValue(lines, 'NetEnabled', '=');\n\n          if (netEnabled) {\n            nics.push({\n              mac: util.getValue(lines, 'MACAddress', '=').toLowerCase(),\n              name: util.getValue(lines, 'Name', '=').replace(/[()\\[\\] ]+/g, '').toLowerCase(),\n              netEnabled: netEnabled === 'TRUE'\n            });\n          }\n        }\n      }\n    }\n\n    return nics;\n  }\n\n  function parseLinesWindowsPerfData(sections) {\n    var perfData = [];\n\n    for (var i in sections) {\n      if (sections.hasOwnProperty(i)) {\n        if (sections[i].trim() !== '') {\n          var lines = sections[i].trim().split('\\r\\n');\n          perfData.push({\n            name: util.getValue(lines, 'Name', '=').replace(/[()\\[\\] ]+/g, '').toLowerCase(),\n            rx: parseInt(util.getValue(lines, 'BytesReceivedPersec', '='), 10),\n            tx: parseInt(util.getValue(lines, 'BytesSentPersec', '='), 10)\n          });\n        }\n      }\n    }\n\n    return perfData;\n  } // fallback - if only callback is given\n\n\n  if (util.isFunction(iface) && !callback) {\n    callback = iface;\n    iface = '';\n  }\n\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      iface = iface || getDefaultNetworkInterface();\n      var result = {\n        iface: iface,\n        operstate: 'unknown',\n        rx: 0,\n        tx: 0,\n        rx_sec: -1,\n        tx_sec: -1,\n        ms: 0\n      };\n      var operstate = 'unknown';\n      var rx = 0;\n      var tx = 0;\n      var cmd, lines, stats;\n\n      if (!_network[iface] || _network[iface] && !_network[iface].ms || _network[iface] && _network[iface].ms && Date.now() - _network[iface].ms >= 500) {\n        if (_linux) {\n          if (fs.existsSync('/sys/class/net/' + iface)) {\n            cmd = 'cat /sys/class/net/' + iface + '/operstate; ' + 'cat /sys/class/net/' + iface + '/statistics/rx_bytes; ' + 'cat /sys/class/net/' + iface + '/statistics/tx_bytes; ';\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                lines = stdout.toString().split('\\n');\n                operstate = lines[0].trim();\n                rx = parseInt(lines[1]);\n                tx = parseInt(lines[2]);\n                result = calcNetworkSpeed(iface, rx, tx, operstate);\n              }\n\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            });\n          } else {\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          }\n        }\n\n        if (_freebsd || _openbsd) {\n          cmd = 'netstat -ibnI ' + iface;\n          exec(cmd, function (error, stdout) {\n            if (!error) {\n              lines = stdout.toString().split('\\n');\n\n              for (var i = 1; i < lines.length; i++) {\n                var line = lines[i].replace(/ +/g, ' ').split(' ');\n\n                if (line && line[0] && line[7] && line[10]) {\n                  rx = rx + parseInt(line[7]);\n                  tx = tx + parseInt(line[10]);\n                  operstate = 'up';\n                }\n              }\n\n              result = calcNetworkSpeed(iface, rx, tx, operstate);\n            }\n\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          });\n        }\n\n        if (_darwin) {\n          cmd = 'ifconfig ' + iface + ' | grep \"status\"';\n          exec(cmd, function (error, stdout) {\n            result.operstate = (stdout.toString().split(':')[1] || '').trim();\n            result.operstate = (result.operstate || '').toLowerCase();\n            result.operstate = result.operstate === 'active' ? 'up' : result.operstate === 'inactive' ? 'down' : 'unknown';\n            cmd = 'netstat -bI ' + iface;\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                lines = stdout.toString().split('\\n'); // if there is less than 2 lines, no information for this interface was found\n\n                if (lines.length > 1 && lines[1].trim() !== '') {\n                  // skip header line\n                  // use the second line because it is tied to the NIC instead of the ipv4 or ipv6 address\n                  stats = lines[1].replace(/ +/g, ' ').split(' ');\n                  rx = parseInt(stats[6]);\n                  tx = parseInt(stats[9]);\n                  result = calcNetworkSpeed(iface, rx, tx, result.operstate);\n                }\n              }\n\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            });\n          });\n        }\n\n        if (_windows) {\n          // NICs\n          var perfData = [];\n          var nics = [];\n          cmd = util.getWmic() + ' nic get MACAddress, name, NetEnabled /value';\n\n          try {\n            exec(cmd, util.execOptsWin, function (error, stdout) {\n              if (!error) {\n                var nsections = stdout.split(/\\n\\s*\\n/);\n                nics = parseLinesWindowsNics(nsections); // Performance Data\n\n                cmd = util.getWmic() + ' path Win32_PerfRawData_Tcpip_NetworkInterface Get name,BytesReceivedPersec,BytesSentPersec,BytesTotalPersec /value';\n                exec(cmd, util.execOptsWin, function (error, stdout) {\n                  if (!error) {\n                    var psections = stdout.split(/\\n\\s*\\n/);\n                    perfData = parseLinesWindowsPerfData(psections);\n                  } // Network Interfaces\n\n\n                  networkInterfaces().then(function (interfaces) {\n                    // get mac from 'interfaces' by interfacename\n                    var mac = '';\n                    interfaces.forEach(function (detail) {\n                      if (detail.iface === iface) {\n                        mac = detail.mac;\n                      }\n                    }); // get name from 'nics' (by macadress)\n\n                    var name = '';\n                    nics.forEach(function (detail) {\n                      if (detail.mac === mac) {\n                        name = detail.name;\n                        operstate = detail.netEnabled ? 'up' : 'down';\n                      }\n                    }); // get bytes sent, received from perfData by name\n\n                    rx = 0;\n                    tx = 0;\n                    perfData.forEach(function (detail) {\n                      if (detail.name === name) {\n                        rx = detail.rx;\n                        tx = detail.tx;\n                      }\n                    });\n\n                    if (rx && tx) {\n                      result = calcNetworkSpeed(iface, parseInt(rx), parseInt(tx), operstate);\n                    }\n\n                    if (callback) {\n                      callback(result);\n                    }\n\n                    resolve(result);\n                  });\n                });\n              }\n            });\n          } catch (e) {\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          }\n        }\n      } else {\n        result.rx = _network[iface].rx;\n        result.tx = _network[iface].tx;\n        result.rx_sec = _network[iface].rx_sec;\n        result.tx_sec = _network[iface].tx_sec;\n        result.ms = _network[iface].last_ms;\n        result.operstate = _network[iface].operstate;\n\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.networkStats = networkStats; // --------------------------\n// NET - connections (sockets)\n\nfunction networkConnections(callback) {\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      var result = [];\n\n      if (_linux || _freebsd || _openbsd) {\n        var cmd = 'netstat -tuna | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\\\\|VERBUNDEN\"';\n        if (_freebsd || _openbsd) cmd = 'netstat -na | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\\\\|VERBUNDEN\"';\n        exec(cmd, {\n          maxBuffer: 1024 * 2000\n        }, function (error, stdout) {\n          if (!error) {\n            var lines = stdout.toString().split('\\n');\n            lines.forEach(function (line) {\n              line = line.replace(/ +/g, ' ').split(' ');\n\n              if (line.length >= 6) {\n                var localip = line[3];\n                var localport = '';\n                var localaddress = line[3].split(':');\n\n                if (localaddress.length > 1) {\n                  localport = localaddress[localaddress.length - 1];\n                  localaddress.pop();\n                  localip = localaddress.join(':');\n                }\n\n                var peerip = line[4];\n                var peerport = '';\n                var peeraddress = line[4].split(':');\n\n                if (peeraddress.length > 1) {\n                  peerport = peeraddress[peeraddress.length - 1];\n                  peeraddress.pop();\n                  peerip = peeraddress.join(':');\n                }\n\n                var connstate = line[5];\n                if (connstate === 'VERBUNDEN') connstate = 'ESTABLISHED';\n\n                if (connstate) {\n                  result.push({\n                    protocol: line[0],\n                    localaddress: localip,\n                    localport: localport,\n                    peeraddress: peerip,\n                    peerport: peerport,\n                    state: connstate\n                  });\n                }\n              }\n            });\n\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          } else {\n            cmd = 'ss -tuna | grep \"ESTAB\\\\|SYN-SENT\\\\|SYN-RECV\\\\|FIN-WAIT1\\\\|FIN-WAIT2\\\\|TIME-WAIT\\\\|CLOSE\\\\|CLOSE-WAIT\\\\|LAST-ACK\\\\|LISTEN\\\\|CLOSING\"';\n            exec(cmd, {\n              maxBuffer: 1024 * 2000\n            }, function (error, stdout) {\n              if (!error) {\n                var _lines3 = stdout.toString().split('\\n');\n\n                _lines3.forEach(function (line) {\n                  line = line.replace(/ +/g, ' ').split(' ');\n\n                  if (line.length >= 6) {\n                    var localip = line[4];\n                    var localport = '';\n                    var localaddress = line[4].split(':');\n\n                    if (localaddress.length > 1) {\n                      localport = localaddress[localaddress.length - 1];\n                      localaddress.pop();\n                      localip = localaddress.join(':');\n                    }\n\n                    var peerip = line[5];\n                    var peerport = '';\n                    var peeraddress = line[5].split(':');\n\n                    if (peeraddress.length > 1) {\n                      peerport = peeraddress[peeraddress.length - 1];\n                      peeraddress.pop();\n                      peerip = peeraddress.join(':');\n                    }\n\n                    var connstate = line[1];\n                    if (connstate === 'ESTAB') connstate = 'ESTABLISHED';\n                    if (connstate === 'TIME-WAIT') connstate = 'TIME_WAIT';\n\n                    if (connstate) {\n                      result.push({\n                        protocol: line[0],\n                        localaddress: localip,\n                        localport: localport,\n                        peeraddress: peerip,\n                        peerport: peerport,\n                        state: connstate\n                      });\n                    }\n                  }\n                });\n              }\n\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            });\n          }\n        });\n      }\n\n      if (_darwin) {\n        var _cmd2 = 'netstat -nat | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\"';\n        exec(_cmd2, {\n          maxBuffer: 1024 * 2000\n        }, function (error, stdout) {\n          if (!error) {\n            var lines = stdout.toString().split('\\n');\n            lines.forEach(function (line) {\n              line = line.replace(/ +/g, ' ').split(' ');\n\n              if (line.length >= 6) {\n                var localip = line[3];\n                var localport = '';\n                var localaddress = line[3].split('.');\n\n                if (localaddress.length > 1) {\n                  localport = localaddress[localaddress.length - 1];\n                  localaddress.pop();\n                  localip = localaddress.join('.');\n                }\n\n                var peerip = line[4];\n                var peerport = '';\n                var peeraddress = line[4].split('.');\n\n                if (peeraddress.length > 1) {\n                  peerport = peeraddress[peeraddress.length - 1];\n                  peeraddress.pop();\n                  peerip = peeraddress.join('.');\n                }\n\n                var connstate = line[5];\n\n                if (connstate) {\n                  result.push({\n                    protocol: line[0],\n                    localaddress: localip,\n                    localport: localport,\n                    peeraddress: peerip,\n                    peerport: peerport,\n                    state: connstate\n                  });\n                }\n              }\n            });\n\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          }\n        });\n      }\n\n      if (_windows) {\n        var _cmd3 = 'netstat -na';\n\n        try {\n          exec(_cmd3, util.execOptsWin, function (error, stdout) {\n            if (!error) {\n              var lines = stdout.toString().split('\\r\\n');\n              lines.forEach(function (line) {\n                line = line.trim().replace(/ +/g, ' ').split(' ');\n\n                if (line.length >= 4) {\n                  var localip = line[1];\n                  var localport = '';\n                  var localaddress = line[1].split(':');\n\n                  if (localaddress.length > 1) {\n                    localport = localaddress[localaddress.length - 1];\n                    localaddress.pop();\n                    localip = localaddress.join(':');\n                  }\n\n                  var peerip = line[2];\n                  var peerport = '';\n                  var peeraddress = line[2].split(':');\n\n                  if (peeraddress.length > 1) {\n                    peerport = peeraddress[peeraddress.length - 1];\n                    peeraddress.pop();\n                    peerip = peeraddress.join(':');\n                  }\n\n                  var connstate = line[3];\n                  if (connstate === 'HERGESTELLT') connstate = 'ESTABLISHED';\n                  if (connstate.startsWith('ABH')) connstate = 'LISTEN';\n                  if (connstate === 'SCHLIESSEN_WARTEN') connstate = 'CLOSE_WAIT';\n                  if (connstate === 'WARTEND') connstate = 'TIME_WAIT';\n                  if (connstate === 'SYN_GESENDET') connstate = 'SYN_SENT';\n                  if (connstate === 'LISTENING') connstate = 'LISTEN';\n                  if (connstate === 'SYN_RECEIVED') connstate = 'SYN_RECV';\n                  if (connstate === 'FIN_WAIT_1') connstate = 'FIN_WAIT1';\n                  if (connstate === 'FIN_WAIT_2') connstate = 'FIN_WAIT2';\n\n                  if (connstate) {\n                    result.push({\n                      protocol: line[0].toLowerCase(),\n                      localaddress: localip,\n                      localport: localport,\n                      peeraddress: peerip,\n                      peerport: peerport,\n                      state: connstate\n                    });\n                  }\n                }\n              });\n\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.networkConnections = networkConnections;","map":null,"metadata":{},"sourceType":"script"}