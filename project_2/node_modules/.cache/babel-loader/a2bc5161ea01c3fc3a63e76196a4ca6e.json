{"ast":null,"code":"'use strict'; // ==================================================================================\n// graphics.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2018\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 7. Graphics (controller, display)\n// ----------------------------------------------------------------------------------\n\nvar exec = require('child_process').exec;\n\nvar util = require('./util');\n\nvar _platform = process.platform;\n\nvar _linux = _platform === 'linux';\n\nvar _darwin = _platform === 'darwin';\n\nvar _windows = _platform === 'win32';\n\nvar _freebsd = _platform === 'freebsd';\n\nvar _openbsd = _platform === 'openbsd';\n\nvar _sunos = _platform === 'sunos';\n\nvar _resolutionx = 0;\nvar _resolutiony = 0;\nvar _pixeldepth = 0;\n\nfunction toInt(value) {\n  var result = parseInt(value, 10);\n\n  if (isNaN(result)) {\n    result = 0;\n  }\n\n  return result;\n}\n\nfunction graphics(callback) {\n  function parseLinesDarwin(lines) {\n    var starts = [];\n    var level = -1;\n    var lastlevel = -1;\n    var controllers = [];\n    var displays = [];\n    var currentController = {};\n    var currentDisplay = {};\n\n    for (var i = 0; i < lines.length; i++) {\n      if ('' !== lines[i].trim()) {\n        var start = lines[i].search(/\\S|$/);\n\n        if (-1 === starts.indexOf(start)) {\n          starts.push(start);\n        }\n\n        level = starts.indexOf(start);\n\n        if (level < lastlevel) {\n          if (Object.keys(currentController).length > 0) {\n            // just changed to Displays\n            controllers.push(currentController);\n            currentController = {};\n          }\n\n          if (Object.keys(currentDisplay).length > 0) {\n            // just changed to Displays\n            displays.push(currentDisplay);\n            currentDisplay = {};\n          }\n        }\n\n        lastlevel = level;\n        var parts = lines[i].split(':');\n\n        if (2 === level) {\n          // grafics controller level\n          if (parts.length > 1 && parts[0].replace(/ +/g, '').toLowerCase().indexOf('chipsetmodel') !== -1) currentController.model = parts[1].trim();\n          if (parts.length > 1 && parts[0].replace(/ +/g, '').toLowerCase().indexOf('bus') !== -1) currentController.bus = parts[1].trim();\n          if (parts.length > 1 && parts[0].replace(/ +/g, '').toLowerCase().indexOf('vendor') !== -1) currentController.vendor = parts[1].split('(')[0].trim();\n\n          if (parts.length > 1 && parts[0].replace(/ +/g, '').toLowerCase().indexOf('vram(total)') !== -1) {\n            currentController.vram = parseInt(parts[1]); // in MB\n\n            currentController.vramDynamic = false;\n          }\n\n          if (parts.length > 1 && parts[0].replace(/ +/g, '').toLowerCase().indexOf('vram(dynamic,max)') !== -1) {\n            currentController.vram = parseInt(parts[1]); // in MB\n\n            currentController.vramDynamic = true;\n          }\n        }\n\n        if (3 === level) {\n          // display controller level\n          if (parts.length > 1 && '' === parts[1]) {\n            currentDisplay.model = parts[0].trim();\n            currentDisplay.main = false;\n            currentDisplay.builtin = false;\n            currentDisplay.connection = '';\n            currentDisplay.sizex = -1;\n            currentDisplay.sizey = -1;\n          }\n        }\n\n        if (4 === level) {\n          // display controller details level\n          if (parts.length > 1 && parts[0].replace(/ +/g, '').toLowerCase().indexOf('resolution') !== -1) {\n            var resolution = parts[1].split('x');\n            currentDisplay.resolutionx = resolution.length > 1 ? parseInt(resolution[0]) : 0;\n            currentDisplay.resolutiony = resolution.length > 1 ? parseInt(resolution[1]) : 0;\n          }\n\n          if (parts.length > 1 && parts[0].replace(/ +/g, '').toLowerCase().indexOf('pixeldepth') !== -1) currentDisplay.pixeldepth = parseInt(parts[1]); // in BIT\n\n          if (parts.length > 1 && parts[0].replace(/ +/g, '').toLowerCase().indexOf('maindisplay') !== -1 && parts[1].replace(/ +/g, '').toLowerCase() === 'yes') currentDisplay.main = true;\n\n          if (parts.length > 1 && parts[0].replace(/ +/g, '').toLowerCase().indexOf('built-in') !== -1 && parts[1].replace(/ +/g, '').toLowerCase() === 'yes') {\n            currentDisplay.builtin = true;\n            currentDisplay.connection = '';\n          }\n\n          if (parts.length > 1 && parts[0].replace(/ +/g, '').toLowerCase().indexOf('connectiontype') !== -1) {\n            currentDisplay.builtin = false;\n            currentDisplay.connection = parts[1].trim();\n          }\n        }\n      }\n    }\n\n    if (Object.keys(currentController).length > 0) {\n      // just changed to Displays\n      controllers.push(currentController);\n    }\n\n    if (Object.keys(currentDisplay).length > 0) {\n      // just changed to Displays\n      displays.push(currentDisplay);\n    }\n\n    return {\n      controllers: controllers,\n      displays: displays\n    };\n  }\n\n  function parseLinesLinuxControllers(lines) {\n    var controllers = [];\n    var currentController = {};\n    var isGraphicsController = false;\n\n    for (var i = 0; i < lines.length; i++) {\n      if ('' !== lines[i].trim()) {\n        if (' ' !== lines[i][0] && '\\t' !== lines[i][0]) {\n          // first line of new entry\n          var vgapos = lines[i].toLowerCase().indexOf('vga');\n\n          var _3dcontrollerpos = lines[i].toLowerCase().indexOf('3d controller');\n\n          if (vgapos !== -1 || _3dcontrollerpos !== -1) {\n            // VGA\n            if (_3dcontrollerpos !== -1 && vgapos === -1) {\n              vgapos = _3dcontrollerpos;\n            }\n\n            if (Object.keys(currentController).length > 0) {\n              // already a controller found\n              controllers.push(currentController);\n              currentController = {};\n            }\n\n            isGraphicsController = true;\n            var endpos = lines[i].search(/\\[[0-9a-f]{4}:[0-9a-f]{4}]|$/);\n            var parts = lines[i].substr(vgapos, endpos - vgapos).split(':');\n\n            if (parts.length > 1) {\n              parts[1] = parts[1].trim();\n\n              if (parts[1].toLowerCase().indexOf('corporation') >= 0) {\n                currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf('corporation') + 11).trim();\n                currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf('corporation') + 11, 200).trim().split('(')[0];\n                currentController.bus = '';\n                currentController.vram = -1;\n                currentController.vramDynamic = false;\n              } else if (parts[1].toLowerCase().indexOf(' inc.') >= 0) {\n                if ((parts[1].match(new RegExp(']', 'g')) || []).length > 1) {\n                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(']') + 1).trim();\n                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(']') + 1, 200).trim().split('(')[0];\n                } else {\n                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(' inc.') + 5).trim();\n                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(' inc.') + 5, 200).trim().split('(')[0];\n                }\n\n                currentController.bus = '';\n                currentController.vram = -1;\n                currentController.vramDynamic = false;\n              }\n            }\n          } else {\n            isGraphicsController = false;\n          }\n        }\n\n        if (isGraphicsController) {\n          // within VGA details\n          var _parts = lines[i].split(':');\n\n          if (_parts.length > 1 && _parts[0].replace(/ +/g, '').toLowerCase().indexOf('devicename') !== -1 && _parts[0].toLowerCase().indexOf('onboard') !== -1) currentController.bus = 'Onboard';\n\n          if (_parts.length > 1 && _parts[0].replace(/ +/g, '').toLowerCase().indexOf('region') !== -1 && _parts[1].toLowerCase().indexOf('memory') !== -1) {\n            var memparts = _parts[1].split('=');\n\n            if (memparts.length > 1) {\n              currentController.vram = parseInt(memparts[1]);\n            }\n          }\n        }\n      }\n    }\n\n    if (Object.keys(currentController).length > 0) {\n      // still controller information available\n      controllers.push(currentController);\n    }\n\n    return controllers;\n  }\n\n  function parseLinesLinuxEdid(edid) {\n    // parsen EDID\n    // --> model\n    // --> resolutionx\n    // --> resolutiony\n    // --> builtin = false\n    // --> pixeldepth (?)\n    // --> sizex\n    // --> sizey\n    var result = {}; // find first \"Detailed Timing Description\"\n\n    var start = 108;\n\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n\n    result.resolutionx = parseInt('0x0' + edid.substr(start + 8, 1) + edid.substr(start + 4, 2));\n    result.resolutiony = parseInt('0x0' + edid.substr(start + 14, 1) + edid.substr(start + 10, 2));\n    result.sizex = parseInt('0x0' + edid.substr(start + 28, 1) + edid.substr(start + 24, 2));\n    result.sizey = parseInt('0x0' + edid.substr(start + 29, 1) + edid.substr(start + 26, 2)); // monitor name\n\n    start = edid.indexOf('000000fc00'); // find first \"Monitor Description Data\"\n\n    if (start >= 0) {\n      var model_raw = edid.substr(start + 10, 26);\n\n      if (model_raw.indexOf('0a') !== -1) {\n        model_raw = model_raw.substr(0, model_raw.indexOf('0a'));\n      }\n\n      result.model = model_raw.match(/.{1,2}/g).map(function (v) {\n        return String.fromCharCode(parseInt(v, 16));\n      }).join('');\n    } else {\n      result.model = '';\n    }\n\n    return result;\n  }\n\n  function parseLinesLinuxDisplays(lines, depth) {\n    var displays = [];\n    var currentDisplay = {};\n    var is_edid = false;\n    var edid_raw = '';\n    var start = 0;\n\n    for (var i = 1; i < lines.length; i++) {\n      // start with second line\n      if ('' !== lines[i].trim()) {\n        if (' ' !== lines[i][0] && '\\t' !== lines[i][0] && lines[i].toLowerCase().indexOf(' connected ') !== -1) {\n          // first line of new entry\n          if (Object.keys(currentDisplay).length > 0) {\n            // push last display to array\n            displays.push(currentDisplay);\n            currentDisplay = {};\n          }\n\n          var parts = lines[i].split(' ');\n          currentDisplay.connection = parts[0];\n          currentDisplay.main = parts[2] === 'primary';\n          currentDisplay.builtin = parts[0].toLowerCase().indexOf('edp') >= 0;\n        } // try to read EDID information\n\n\n        if (is_edid) {\n          if (lines[i].search(/\\S|$/) > start) {\n            edid_raw += lines[i].toLowerCase().trim();\n          } else {\n            // parsen EDID\n            var edid_decoded = parseLinesLinuxEdid(edid_raw);\n            currentDisplay.model = edid_decoded.model;\n            currentDisplay.resolutionx = edid_decoded.resolutionx;\n            currentDisplay.resolutiony = edid_decoded.resolutiony;\n            currentDisplay.sizex = edid_decoded.sizex;\n            currentDisplay.sizey = edid_decoded.sizey;\n            currentDisplay.pixeldepth = depth;\n            is_edid = false;\n          }\n        }\n\n        if (lines[i].toLowerCase().indexOf('edid:') !== -1) {\n          is_edid = true;\n          start = lines[i].search(/\\S|$/);\n        }\n      }\n    } // pushen displays\n\n\n    if (Object.keys(currentDisplay).length > 0) {\n      // still information there\n      displays.push(currentDisplay);\n    }\n\n    return displays;\n  } // function starts here\n\n\n  return new Promise(function (resolve) {\n    process.nextTick(function () {\n      var result = {\n        controllers: [],\n        displays: []\n      };\n\n      if (_darwin) {\n        var cmd = 'system_profiler SPDisplaysDataType';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            var lines = stdout.toString().split('\\n');\n            result = parseLinesDarwin(lines);\n          }\n\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        });\n      }\n\n      if (_linux) {\n        var _cmd = 'lspci -vvv  2>/dev/null';\n        exec(_cmd, function (error, stdout) {\n          if (!error) {\n            var lines = stdout.toString().split('\\n');\n            result.controllers = parseLinesLinuxControllers(lines);\n          }\n\n          var cmd = 'xdpyinfo 2>/dev/null | grep \\'depth of root window\\' | awk \\'{ print $5 }\\'';\n          exec(cmd, function (error, stdout) {\n            var depth = 0;\n\n            if (!error) {\n              var _lines = stdout.toString().split('\\n');\n\n              depth = parseInt(_lines[0]) || 0;\n            }\n\n            var cmd = 'xrandr --verbose 2>/dev/null';\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                var _lines2 = stdout.toString().split('\\n');\n\n                result.displays = parseLinesLinuxDisplays(_lines2, depth);\n              }\n\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            });\n          });\n        });\n      }\n\n      if (_freebsd || _openbsd) {\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n\n      if (_sunos) {\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n\n      if (_windows) {\n        // https://blogs.technet.microsoft.com/heyscriptingguy/2013/10/03/use-powershell-to-discover-multi-monitor-information/\n        try {\n          util.execWin(util.getWmic() + ' path win32_VideoController get AdapterCompatibility, AdapterDACType, name, PNPDeviceID, CurrentVerticalResolution, CurrentHorizontalResolution, CurrentNumberOfColors, AdapterRAM, CurrentBitsPerPixel, CurrentRefreshRate, MinRefreshRate, MaxRefreshRate, VideoMemoryType /value', util.execOptsWin, function (error, stdout) {\n            if (!error) {\n              var csections = stdout.split(/\\n\\s*\\n/);\n              result.controllers = parseLinesWindowsControllers(csections);\n              util.execWin(util.getWmic() + ' path win32_desktopmonitor get Caption, MonitorManufacturer, MonitorType, ScreenWidth, ScreenHeight /value', util.execOptsWin, function (error, stdout) {\n                var dsections = stdout.split(/\\n\\s*\\n/);\n\n                if (!error) {\n                  result.displays = parseLinesWindowsDisplays(dsections);\n\n                  if (result.controllers.length === 1 && result.displays.length === 1) {\n                    if (_resolutionx && !result.displays[0].resolutionx) {\n                      result.displays[0].resolutionx = _resolutionx;\n                    }\n\n                    if (_resolutiony && !result.displays[0].resolutiony) {\n                      result.displays[0].resolutiony = _resolutiony;\n                    }\n\n                    if (_pixeldepth) {\n                      result.displays[0].pixeldepth = _pixeldepth;\n                    }\n                  }\n                }\n\n                if (callback) {\n                  callback(result);\n                }\n\n                resolve(result);\n              });\n            }\n          });\n        } catch (e) {\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        }\n      }\n    });\n  });\n\n  function parseLinesWindowsControllers(sections) {\n    var controllers = [];\n\n    for (var i in sections) {\n      if (sections.hasOwnProperty(i)) {\n        if (sections[i].trim() !== '') {\n          var lines = sections[i].trim().split('\\r\\n');\n          controllers.push({\n            model: util.getValue(lines, 'name', '='),\n            vendor: util.getValue(lines, 'AdapterCompatibility', '='),\n            bus: util.getValue(lines, 'PNPDeviceID', '=').startsWith('PCI') ? 'PCI' : '',\n            vram: parseInt(util.getValue(lines, 'AdapterRAM', '='), 10) / 1024 / 1024,\n            vramDynamic: util.getValue(lines, 'VideoMemoryType', '=') === '2'\n          });\n          _resolutionx = toInt(util.getValue(lines, 'CurrentHorizontalResolution', '='));\n          _resolutiony = toInt(util.getValue(lines, 'CurrentVerticalResolution', '='));\n          _pixeldepth = toInt(util.getValue(lines, 'CurrentBitsPerPixel', '='));\n        }\n      }\n    }\n\n    return controllers;\n  }\n\n  function parseLinesWindowsDisplays(sections) {\n    var displays = [];\n\n    for (var i in sections) {\n      if (sections.hasOwnProperty(i)) {\n        if (sections[i].trim() !== '') {\n          var lines = sections[i].trim().split('\\r\\n');\n          displays.push({\n            model: util.getValue(lines, 'MonitorManufacturer', '='),\n            main: false,\n            builtin: false,\n            connection: '',\n            resolutionx: toInt(util.getValue(lines, 'ScreenWidth', '=')),\n            resolutiony: toInt(util.getValue(lines, 'ScreenHeight', '=')),\n            sizex: -1,\n            sizey: -1\n          });\n        }\n      }\n    }\n\n    return displays;\n  }\n}\n\nexports.graphics = graphics;","map":null,"metadata":{},"sourceType":"script"}